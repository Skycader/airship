// === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–†–¢–´ ===
const map = L.map("map").setView([55.75, 37.62], 4);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "&copy; OpenStreetMap contributors",
}).addTo(map);

// === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
let airshipMarker = null;
let flagMarker = null;
let targetMarker = null;
let directionArrow = null;

const timeSteps = [
  0.1, // 0
  1, // 1
  2, // 2
  5, // 3
  10, // 4
  20, // 5
  30, // 6
  40, // 7
  50, // 8
  60, // 9
  70, // 10
  80, // 11
  90, // 12
  100, // 13
  1000, // 14
];
let timeWarpFactor = 1;
let isPaused = false;

// === –¢–û–ü–õ–ò–í–û (–î–ò–ó–ï–õ–¨) ===
const MAX_FUEL_CAPACITY = 88000; // –ª–∏—Ç—Ä–æ–≤
// –¢–∞–±–ª–∏—Ü–∞ —Ä–∞—Å—Ö–æ–¥–∞: [–º–æ—â–Ω–æ—Å—Ç—å %, —Ä–∞—Å—Ö–æ–¥ –ª/—á, —Å–∫–æ—Ä–æ—Å—Ç—å –∫–º/—á]
const FUEL_CONSUMPTION_TABLE = [
  [10, 85, 63],
  [20, 170, 79],
  [30, 254, 90],
  [40, 339, 100],
  [50, 424, 107],
  [60, 508, 114],
  [70, 593, 120],
  [80, 678, 125],
  [90, 762, 130],
  [100, 847, 135],
];

// === –ú–ê–°–®–¢–ê–ë ===
// –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: 0 = –¥–∞–ª–µ–∫–æ (1000x), 7 = –±–ª–∏–∑–∫–æ (1x)
const ZOOM_SCALE_LEVELS = [2, 4, 6, 8, 9, 10, 11, 12];
let currentZoomScaleIndex = 7; // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1x

// === –§–ò–ó–ò–ö–ê ===
const ENGINE_POWER_RATE = 1.0; // %/—Å
const MAX_TURN_RATE = 3;
const MIN_TURN_RATE = 0.3;
const PROPELLER_BASE_SCALE = 4.0;

// === –í–ï–¢–ï–† ===
let windSpeedBf = 3; // —Å–∏–ª–∞ –≤–µ—Ç—Ä–∞ –ø–æ —à–∫–∞–ª–µ –ë–æ—Ñ–æ—Ä—Ç–∞ (0‚Äì12)
let windDirection = 0; // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç—Ä–∞ (–≥—Ä–∞–¥—É—Å—ã, –æ—Ç–∫—É–¥–∞ –¥—É–µ—Ç)
let windMode = "auto"; // 'auto' –∏–ª–∏ 'manual'

// === –î–ê–ù–ù–´–ï –î–ò–†–ò–ñ–ê–ë–õ–Ø ===
let airshipData = {
  lat: 0,
  lng: 0,
  heading: 0,
  speed: 0,
  throttle: 0,
  rudder: 0,
  angularVelocity: 0,
  lastUpdate: Date.now(),
  propRotationAngle: 0,
  flagEnabled: false,
  followEnabled: false,
  autopilotEnabled: false,
  fastBrakeEnabled: false,
  startTime: null,
  totalDistanceMeters: 0,
  fuelReserve: 0, // –ª–∏—Ç—Ä—ã
  totalFuelBurned: 0, // –ª–∏—Ç—Ä—ã
  hasTarget: false,
  targetLat: null,
  targetLng: null,
  virtualStartTime: null,
  enginePower: 0, // %
  engineReversing: false,
};

// === –ú–ï–¢–ö–ò –ò–ö–û–ù–û–ö ===
const flagIcon = L.divIcon({
  className: "",
  html: "üö©",
  iconSize: [20, 24],
  iconAnchor: [10, 24],
});

const targetIcon = L.divIcon({
  className: "",
  html: "üéØ",
  iconSize: [24, 24],
  iconAnchor: [12, 12],
});

// === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===

// –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –ø–æ —Ç–∞–±–ª–∏—Ü–µ —Ä–∞—Å—Ö–æ–¥–∞
function interpolateFuelAndSpeed(powerPercent) {
  if (powerPercent <= 0) return { fuelRate: 0, speed: 0 };
  if (powerPercent >= 100) return { fuelRate: 847, speed: 135 };

  for (let i = 0; i < FUEL_CONSUMPTION_TABLE.length; i++) {
    const [p, f, s] = FUEL_CONSUMPTION_TABLE[i];
    if (powerPercent <= p) {
      if (i === 0) return { fuelRate: f, speed: s };
      const [p0, f0, s0] = FUEL_CONSUMPTION_TABLE[i - 1];
      const t = (powerPercent - p0) / (p - p0);
      return {
        fuelRate: f0 + t * (f - f0),
        speed: s0 + t * (s - s0),
      };
    }
  }
  return { fuelRate: 847, speed: 135 };
}

// –†–∞—Å—á—ë—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤–µ—Ç—Ä–∞ –≤ –º/—Å –ø–æ —à–∫–∞–ª–µ –ë–æ—Ñ–æ—Ä—Ç–∞
function beaufortToMps(bf) {
  const scale = [
    0, 0.5, 1.6, 3.4, 5.5, 8.0, 10.8, 13.9, 17.2, 20.8, 24.5, 28.5, 32.7,
  ];
  return scale[Math.min(12, Math.max(0, Math.round(bf)))];
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ URL (–±–µ–∑ —Ç–æ–ø–ª–∏–≤–∞ –∏ –≤—Ä–µ–º–µ–Ω–∏)
let lastUrlUpdate = 0;
function updateUrl() {
  const now = Date.now();
  if (now - lastUrlUpdate < 1000) return;
  lastUrlUpdate = now;

  const url = new URL(window.location);
  url.searchParams.set("lat", airshipData.lat.toFixed(6));
  url.searchParams.set("lng", airshipData.lng.toFixed(6));
  url.searchParams.set("hdg", airshipData.heading.toFixed(1));
  url.searchParams.set("spd", airshipData.speed.toFixed(1));
  url.searchParams.set("thr", airshipData.throttle);
  url.searchParams.set("rud", airshipData.rudder.toFixed(1));
  url.searchParams.set("eng", airshipData.enginePower.toFixed(1));
  url.searchParams.set("tgt", airshipData.hasTarget ? "1" : "0");
  if (airshipData.hasTarget) {
    url.searchParams.set("tlt", airshipData.targetLat.toFixed(6));
    url.searchParams.set("tlg", airshipData.targetLng.toFixed(6));
  }
  url.searchParams.set("apl", airshipData.autopilotEnabled ? "1" : "0");
  url.searchParams.set("fbr", airshipData.fastBrakeEnabled ? "1" : "0");
  url.searchParams.set("vst", Math.floor(airshipData.virtualStartTime / 1000));
  window.history.replaceState(null, "", url);
}

// === –ì–†–ê–§–ò–ö–ê ===

function getAirshipSvg(zoom, heading, propRotationAngle) {
  if (zoom <= 8) {
    return `<svg viewBox="0 0 10 10" width="10" height="10">
              <circle cx="5" cy="5" r="4" fill="#ff3300" stroke="#000" stroke-width="1"/>
            </svg>`;
  }

  const metersPerPixel =
    (156543.03392 * Math.cos((airshipData.lat * Math.PI) / 180)) /
    Math.pow(2, zoom);
  const lengthPx = 500 / metersPerPixel;
  const widthPx = lengthPx * 0.22;

  const propSize = widthPx * 0.3;
  const centerY = lengthPx * 0.92;
  const offsetX = widthPx * 0.15;
  const leftPropX = widthPx / 2 - offsetX;
  const rightPropX = widthPx / 2 + offsetX;

  // === –ö–û–ú–ü–ê–° –í–ï–¢–†–ê (—Ü–µ–Ω—Ç—Ä) ===
  const windCompassSize = Math.min(40, widthPx * 0.3);
  const windArrowAngle = windDirection; // –≤–µ—Ç–µ—Ä –¥—É–µ—Ç –û–¢ —ç—Ç–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
  const windArrowRad = ((windArrowAngle - 90) * Math.PI) / 180;
  const windArrowLength = windCompassSize * 0.35;
  const windArrowX =
    windCompassSize / 2 + windArrowLength * Math.cos(windArrowRad);
  const windArrowY =
    windCompassSize / 2 + windArrowLength * Math.sin(windArrowRad);

  // === –ö–û–ú–ü–ê–° –¶–ï–õ–ò (–Ω–æ—Å) ===
  let targetCompassSvg = "";
  if (airshipData.hasTarget) {
    const R = 6378137;
    const lat1 = (airshipData.lat * Math.PI) / 180;
    const lon1 = (airshipData.lng * Math.PI) / 180;
    const lat2 = (airshipData.targetLat * Math.PI) / 180;
    const lon2 = (airshipData.targetLng * Math.PI) / 180;
    const dLon = lon2 - lon1;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x =
      Math.cos(lat1) * Math.sin(lat2) -
      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const bearingToTarget = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;

    const targetCompassSize = windCompassSize;
    const targetArrowAngle = bearingToTarget;
    const targetArrowRad = ((targetArrowAngle - 90) * Math.PI) / 180;
    const targetArrowLength = targetCompassSize * 0.35;
    const targetArrowX =
      targetCompassSize / 2 + targetArrowLength * Math.cos(targetArrowRad);
    const targetArrowY =
      targetCompassSize / 2 + targetArrowLength * Math.sin(targetArrowRad);

    targetCompassSvg = `
      <g transform="translate(${widthPx / 2 - targetCompassSize / 2}, ${lengthPx * 0.1})">
        <circle cx="${targetCompassSize / 2}" cy="${targetCompassSize / 2}" r="${targetCompassSize / 2}" fill="#000" stroke="#fff" stroke-width="1"/>
        <line x1="${targetCompassSize / 2}" y1="${targetCompassSize / 2}" x2="${targetArrowX}" y2="${targetArrowY}" stroke="#0f0" stroke-width="2" marker-end="url(#arrowhead-target)"/>
        <text x="${targetCompassSize / 2}" y="12" text-anchor="middle" fill="#fff" font-size="10" font-family="Arial">N</text>
        <text x="${targetCompassSize - 8}" y="${targetCompassSize / 2 + 4}" text-anchor="end" fill="#fff" font-size="10" font-family="Arial">E</text>
        <text x="${targetCompassSize / 2}" y="${targetCompassSize - 2}" text-anchor="middle" fill="#fff" font-size="10" font-family="Arial">S</text>
        <text x="8" y="${targetCompassSize / 2 + 4}" text-anchor="start" fill="#fff" font-size="10" font-family="Arial">W</text>
      </g>
      <defs>
        <marker id="arrowhead-target" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto">
          <polygon points="0,0 6,2 0,4" fill="#0f0"/>
        </marker>
      </defs>
    `;
  }

  return `
    <svg viewBox="0 0 ${widthPx} ${lengthPx}" 
         width="${widthPx}" height="${lengthPx}"
         style="transform: rotate(${heading}deg); transform-origin: center;">
      <ellipse cx="${widthPx / 2}" cy="${lengthPx / 2}" 
               rx="${widthPx / 2}" ry="${lengthPx / 2}" 
               fill="#3a5ca0" stroke="#1a3a6a" stroke-width="1"/>
      <image href="https://cdn-icons-png.flaticon.com/512/166/166062.png"
             x="${leftPropX - propSize / 2}" y="${centerY - propSize / 2}"
             width="${propSize}" height="${propSize}"
             transform="rotate(${propRotationAngle} ${leftPropX} ${centerY})" />
      <image href="https://cdn-icons-png.flaticon.com/512/166/166062.png"
             x="${rightPropX - propSize / 2}" y="${centerY - propSize / 2}"
             width="${propSize}" height="${propSize}"
             transform="rotate(${-propRotationAngle} ${rightPropX} ${centerY})" />
      
      <!-- –ö–æ–º–ø–∞—Å –≤–µ—Ç—Ä–∞ (—Ü–µ–Ω—Ç—Ä) -->
      <g transform="translate(${widthPx / 2 - windCompassSize / 2}, ${lengthPx / 2 - windCompassSize / 2})">
        <circle cx="${windCompassSize / 2}" cy="${windCompassSize / 2}" r="${windCompassSize / 2}" fill="#000" stroke="#ccc" stroke-width="1"/>
        <line x1="${windCompassSize / 2}" y1="${windCompassSize / 2}" x2="${windArrowX}" y2="${windArrowY}" stroke="#ff0" stroke-width="2" marker-end="url(#arrowhead-wind)"/>
        <text x="${windCompassSize / 2}" y="12" text-anchor="middle" fill="#fff" font-size="10" font-family="Arial">N</text>
        <text x="${windCompassSize - 8}" y="${windCompassSize / 2 + 4}" text-anchor="end" fill="#fff" font-size="10" font-family="Arial">E</text>
        <text x="${windCompassSize / 2}" y="${windCompassSize - 2}" text-anchor="middle" fill="#fff" font-size="10" font-family="Arial">S</text>
        <text x="8" y="${windCompassSize / 2 + 4}" text-anchor="start" fill="#fff" font-size="10" font-family="Arial">W</text>
      </g>
      <defs>
        <marker id="arrowhead-wind" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto">
          <polygon points="0,0 6,2 0,4" fill="#ff0"/>
        </marker>
      </defs>
      
      ${targetCompassSvg}
    </svg>`;
}

function updateAirshipIcon() {
  if (!airshipMarker) return;
  const zoom = map.getZoom();
  const svgHtml = getAirshipSvg(
    zoom,
    airshipData.heading,
    airshipData.propRotationAngle,
  );
  const newIcon = L.divIcon({ className: "", html: svgHtml, iconSize: null });
  airshipMarker.setIcon(newIcon);
}

// === –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï ===

function updateFlag() {
  const showFlag = document.getElementById("flagToggle").checked;
  if (showFlag && airshipMarker) {
    if (!flagMarker) {
      flagMarker = L.marker([airshipData.lat, airshipData.lng], {
        icon: flagIcon,
      }).addTo(map);
    } else {
      flagMarker.setLatLng([airshipData.lat, airshipData.lng]);
    }
  } else {
    if (flagMarker) {
      map.removeLayer(flagMarker);
      flagMarker = null;
    }
  }
}

function setTarget(lat, lng) {
  airshipData.hasTarget = true;
  airshipData.targetLat = lat;
  airshipData.targetLng = lng;
  if (targetMarker) map.removeLayer(targetMarker);
  targetMarker = L.marker([lat, lng], { icon: targetIcon }).addTo(map);
  document.getElementById("targetBtn").textContent = "–£–¥–∞–ª–∏—Ç—å –º–∞—Ä–∫–µ—Ä";
  document.getElementById("autopilotToggle").disabled = false;
  updateDirectionArrow();
}

function removeTarget() {
  airshipData.hasTarget = false;
  airshipData.targetLat = null;
  airshipData.targetLng = null;
  if (targetMarker) {
    map.removeLayer(targetMarker);
    targetMarker = null;
  }
  if (directionArrow) {
    map.removeLayer(directionArrow);
    directionArrow = null;
  }
  document.getElementById("targetBtn").textContent = "–î–æ–±–∞–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä";
  document.getElementById("autopilotToggle").checked = false;
  document.getElementById("autopilotToggle").disabled = true;
  airshipData.autopilotEnabled = false;
}

function updateDirectionArrow() {
  if (!airshipData.hasTarget || !airshipMarker) return;
  if (directionArrow) map.removeLayer(directionArrow);

  const R = 6378137;
  const lat1 = (airshipData.lat * Math.PI) / 180;
  const lon1 = (airshipData.lng * Math.PI) / 180;
  const lat2 = (airshipData.targetLat * Math.PI) / 180;
  const lon2 = (airshipData.targetLng * Math.PI) / 180;

  const dLon = lon2 - lon1;
  const y = Math.sin(dLon) * Math.cos(lat2);
  const x =
    Math.cos(lat1) * Math.sin(lat2) -
    Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
  const bearing = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;

  const dx = R * Math.cos(lat1) * Math.sin(dLon);
  const dy = R * (Math.sin(lat2) - Math.sin(lat1));
  const distance = Math.sqrt(dx * dx + dy * dy);

  let timeToTargetText = "~ ‚àû";
  if (Math.abs(airshipData.speed) > 5) {
    const speedMs = Math.abs(airshipData.speed) / 3.6;
    const seconds = distance / speedMs;
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) {
      timeToTargetText = `~ ${hours} —á. ${minutes} –º–∏–Ω.`;
    } else {
      timeToTargetText = `~ ${minutes} –º–∏–Ω.`;
    }
  }

  const arrowLength = 60;
  const arrowRad = ((bearing - 90) * Math.PI) / 180;
  const arrowEndX = arrowLength * Math.cos(arrowRad);
  const arrowEndY = arrowLength * Math.sin(arrowRad);

  const kmInt = Math.floor(distance / 1000);
  const kmText = kmInt.toString().padStart(4, "0") + " –∫–º";

  const size = 200;
  const centerX = size / 2;
  const centerY = size / 2;

  const arrowSvg = `
    <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="overflow:visible;">
      <line x1="${centerX}" y1="${centerY}" 
            x2="${centerX + arrowEndX}" y2="${centerY + arrowEndY}" 
            stroke="#000" stroke-width="3" marker-end="url(#arrowhead)"/>
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#000"/>
        </marker>
      </defs>
      <rect x="${centerX + arrowEndX + 5}" y="${centerY + arrowEndY - 36}" 
            width="80" height="36" rx="5" ry="5" fill="#000" />
      <text x="${centerX + arrowEndX + 45}" y="${centerY + arrowEndY - 20}" 
            fill="#fff" font-size="12" text-anchor="middle" font-family="Arial">
        ${kmText}
      </text>
      <text x="${centerX + arrowEndX + 45}" y="${centerY + arrowEndY - 5}" 
            fill="#fff" font-size="11" text-anchor="middle" font-family="Arial">
        ${timeToTargetText}
      </text>
    </svg>`;

  const arrowIcon = L.divIcon({
    className: "",
    html: arrowSvg,
    iconSize: [size, size],
    iconAnchor: [centerX, centerY],
  });

  directionArrow = L.marker([airshipData.lat, airshipData.lng], {
    icon: arrowIcon,
  }).addTo(map);
}

function focusOnAirship(optimalZoom = 12) {
  if (airshipMarker) {
    map.setView([airshipData.lat, airshipData.lng], optimalZoom);
  }
}

// === –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï ===

function formatDistance(meters) {
  const km = Math.floor(meters / 1000);
  const m = Math.floor(meters % 1000);
  return `${km} –∫–º ${m} –º`;
}

function formatFuel(liters) {
  return liters.toFixed(3);
}

function formatTime(totalSeconds) {
  const totalSec = Math.floor(totalSeconds);
  const days = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const minutes = Math.floor((totalSec % 3600) / 60);
  const seconds = totalSec % 60;

  if (days > 0) {
    return `${days} –¥–Ω. ${hours} —á. ${minutes} –º–∏–Ω.`;
  } else {
    return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
}

function calculateFuelTimeRemaining() {
  if (airshipData.fuelReserve <= 0) return "00:00";
  const powerPercent = Math.abs(airshipData.enginePower);
  if (powerPercent < 0.1) return "‚àû";

  const { fuelRate } = interpolateFuelAndSpeed(powerPercent); // –ª/—á
  if (fuelRate <= 0) return "‚àû";

  const hours = airshipData.fuelReserve / fuelRate;
  if (hours > 24) return "‚àû";

  const h = Math.floor(hours).toString().padStart(2, "0");
  const m = Math.floor((hours % 1) * 60)
    .toString()
    .padStart(2, "0");
  return `${h}:${m}`;
}

function updateStats() {
  const elapsedTime = (Date.now() - airshipData.startTime) / 1000; // —Å–µ–∫—É–Ω–¥—ã —Å –Ω–∞—á–∞–ª–∞ –ø–æ–ª—ë—Ç–∞
  const fuelTime = calculateFuelTimeRemaining();

  document.getElementById("stats").innerHTML =
    `–ü—Ä–æ–π–¥–µ–Ω–æ: ${formatDistance(airshipData.totalDistanceMeters)}<br>` +
    `–î–∏–∑–µ–ª—å: ${formatFuel(airshipData.totalFuelBurned)} / ${formatFuel(airshipData.fuelReserve)} –ª (${fuelTime})<br>` +
    `–í—Ä–µ–º—è –≤ –ø—É—Ç–∏: ${formatTime(elapsedTime)}`;
}

function updateDisplays() {
  const throttleSlider = document.getElementById("throttleSlider");
  const rudderSlider = document.getElementById("rudderSlider");
  const rudderValue = document.getElementById("rudderValue");
  const throttleValue = document.getElementById("throttleValue");

  rudderSlider.value = Math.round(airshipData.rudder * 10);
  throttleSlider.value = airshipData.throttle;

  const throttleLabels = {
    "-5": "ASTERN FULL",
    "-4": "ASTERN HALF",
    "-3": "ASTERN SLOW",
    "-2": "ASTERN DEAD SLOW",
    "-1": "DEAD SLOW (astern)",
    0: "STOP",
    1: "DEAD SLOW",
    2: "SLOW",
    3: "HALF",
    4: "FULL",
    5: "FULL",
  };
  rudderValue.textContent = airshipData.rudder.toFixed(1) + "¬∞";
  throttleValue.textContent = throttleLabels[airshipData.throttle] || "STOP";

  document.getElementById("speedometer").textContent =
    airshipData.speed.toFixed(1) + " –∫–º/—á";
  const sign = airshipData.enginePower >= 0 ? "" : "-";
  document.getElementById("enginePowerDisplay").textContent =
    sign + Math.abs(Math.round(airshipData.enginePower)) + "%";

  let courseDeviation = 0;
  if (airshipData.hasTarget) {
    const R = 6378137;
    const lat1 = (airshipData.lat * Math.PI) / 180;
    const lon1 = (airshipData.lng * Math.PI) / 180;
    const lat2 = (airshipData.targetLat * Math.PI) / 180;
    const lon2 = (airshipData.targetLng * Math.PI) / 180;
    const dLon = lon2 - lon1;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x =
      Math.cos(lat1) * Math.sin(lat2) -
      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const bearingToTarget = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;
    courseDeviation = bearingToTarget - airshipData.heading;
    if (courseDeviation > 180) courseDeviation -= 360;
    if (courseDeviation < -180) courseDeviation += 360;
  }
  document.getElementById("compass").textContent =
    `${Math.round(airshipData.heading)}¬∞ (${Math.abs(Math.round(courseDeviation))}¬∞)`;

  document.getElementById("timeWarpValue").textContent = timeWarpFactor + "x";
  const zoomLabels = ["1000x", "500x", "200x", "100x", "10x", "5x", "2x", "1x"];
  document.getElementById("zoomScaleValue").textContent =
    zoomLabels[currentZoomScaleIndex];
  document.getElementById("pauseBtn").textContent = isPaused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
  document.getElementById("autopilotToggle").checked =
    airshipData.autopilotEnabled;
  document.getElementById("fastBrakeToggle").checked =
    airshipData.fastBrakeEnabled;
}

// === –§–ò–ó–ò–ö–ê –ò –í–ï–¢–ï–† ===

function applyWindEffect() {
  const windSpeedMs = beaufortToMps(windSpeedBf);
  const windAngleRad = (windDirection * Math.PI) / 180;

  // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–µ—Ç—Ä–∞
  const windX = windSpeedMs * Math.sin(windAngleRad); // –≤–æ—Å—Ç–æ–∫
  const windY = windSpeedMs * Math.cos(windAngleRad); // —Å–µ–≤–µ—Ä

  // –î–≤–∏–∂–µ–Ω–∏–µ –¥–∏—Ä–∏–∂–∞–±–ª—è
  const shipAngleRad = (airshipData.heading * Math.PI) / 180;
  const shipSpeedMs = Math.abs(airshipData.speed) / 3.6;
  const shipX =
    shipSpeedMs * Math.sin(shipAngleRad) * Math.sign(airshipData.speed);
  const shipY =
    shipSpeedMs * Math.cos(shipAngleRad) * Math.sign(airshipData.speed);

  // –ò—Ç–æ–≥–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∑–µ–º–ª–∏
  const totalX = shipX + windX;
  const totalY = shipY + windY;
  airshipData.groundSpeed = Math.sqrt(totalX * totalX + totalY * totalY) * 3.6; // –∫–º/—á
}

// === –ê–í–¢–û–ü–ò–õ–û–¢ ===

function runAutopilot() {
  if (
    !airshipData.hasTarget ||
    !airshipData.autopilotEnabled ||
    airshipData.fuelReserve <= 0
  )
    return;

  const R = 6378137;
  const lat1 = (airshipData.lat * Math.PI) / 180;
  const lon1 = (airshipData.lng * Math.PI) / 180;
  const lat2 = (airshipData.targetLat * Math.PI) / 180;
  const lon2 = (airshipData.targetLng * Math.PI) / 180;

  const dLon = lon2 - lon1;
  const y = Math.sin(dLon) * Math.cos(lat2);
  const x =
    Math.cos(lat1) * Math.sin(lat2) -
    Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
  const bearingToTarget = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;

  const dx = R * Math.cos(lat1) * Math.sin(dLon);
  const dy = R * (Math.sin(lat2) - Math.sin(lat1));
  const distanceToTarget = Math.sqrt(dx * dx + dy * dy);

  // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–º
  let headingError = bearingToTarget - airshipData.heading;
  if (headingError > 180) headingError -= 360;
  if (headingError < -180) headingError += 360;

  let rudderCommand = headingError * 0.01;
  rudderCommand = Math.max(-0.5, Math.min(0.5, rudderCommand));
  airshipData.rudder = rudderCommand;

  // –¢–æ—Ä–º–æ–∂–µ–Ω–∏–µ
  const speedMs = airshipData.speed / 3.6;
  const decel = 0.8 / 3.6; // ACCELERATION_REVERSE
  const brakingDistance = (speedMs * speedMs) / (2 * decel);

  let throttleCommand = 0;
  if (distanceToTarget < 100) {
    throttleCommand = 0;
  } else if (distanceToTarget < brakingDistance + 500) {
    throttleCommand = -5;
  } else {
    throttleCommand = 5;
  }

  airshipData.throttle = Math.round(throttleCommand);
  document.getElementById("rudderSlider").value = Math.round(
    rudderCommand * 10,
  );
  document.getElementById("throttleSlider").value = airshipData.throttle;
}

// === –ü–†–û–ü–£–°–ö –í–†–ï–ú–ï–ù–ò ===

function skipSimulationTime(secondsToSkip) {
  if (!airshipMarker || secondsToSkip <= 0) return;

  const simulatedSeconds = secondsToSkip * timeWarpFactor;

  let currentLat = airshipData.lat;
  let currentLng = airshipData.lng;
  let currentHeading = airshipData.heading;
  let currentSpeed = airshipData.speed;
  let currentAngularVel = airshipData.angularVelocity;
  let currentPropAngle = airshipData.propRotationAngle;
  let fuelBurned = 0;
  let currentEnginePower = airshipData.enginePower;
  let currentFuelReserve = airshipData.fuelReserve;
  let currentThrottle = airshipData.throttle;

  let remaining = simulatedSeconds;
  const step = 1;
  while (remaining > 0 && currentFuelReserve > 0) {
    const dt = Math.min(step, remaining);
    remaining -= dt;

    // –ë—ã—Å—Ç—Ä–æ–µ —Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ
    if (airshipData.fastBrakeEnabled && currentSpeed > 5) {
      currentThrottle = -5;
    } else if (currentSpeed <= 5 && airshipData.fastBrakeEnabled) {
      airshipData.fastBrakeEnabled = false;
      currentThrottle = 0;
    }

    // –ê–≤—Ç–æ–ø–∏–ª–æ—Ç
    if (airshipData.autopilotEnabled && airshipData.hasTarget) {
      const R = 6378137;
      const lat1 = (currentLat * Math.PI) / 180;
      const lon1 = (currentLng * Math.PI) / 180;
      const lat2 = (airshipData.targetLat * Math.PI) / 180;
      const lon2 = (airshipData.targetLng * Math.PI) / 180;
      const dLon = lon2 - lon1;
      const dx = R * Math.cos(lat1) * Math.sin(dLon);
      const dy = R * (Math.sin(lat2) - Math.sin(lat1));
      const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
      const speedMs = Math.abs(currentSpeed) / 3.6;
      const decel = 0.8 / 3.6;
      const brakingDistance = (speedMs * speedMs) / (2 * decel);
      if (distanceToTarget < 100) {
        currentThrottle = 0;
      } else if (distanceToTarget < brakingDistance + 500) {
        currentThrottle = -5;
      } else {
        currentThrottle = 5;
      }
    }

    // –î–≤–∏–≥–∞—Ç–µ–ª—å
    const currentSign = Math.sign(currentEnginePower);
    const targetSign = Math.sign(currentThrottle);
    if (currentSign !== targetSign && currentEnginePower !== 0) {
      if (currentEnginePower > 0) {
        currentEnginePower = Math.max(
          0,
          currentEnginePower - ENGINE_POWER_RATE * dt,
        );
      } else {
        currentEnginePower = Math.min(
          0,
          currentEnginePower + ENGINE_POWER_RATE * dt,
        );
      }
      if (Math.abs(currentEnginePower) <= 0.1) {
        currentEnginePower = 0;
      }
    } else {
      const targetEnginePower = currentThrottle * 20;
      if (currentEnginePower < targetEnginePower) {
        currentEnginePower = Math.min(
          targetEnginePower,
          currentEnginePower + ENGINE_POWER_RATE * dt,
        );
      } else if (currentEnginePower > targetEnginePower) {
        currentEnginePower = Math.max(
          targetEnginePower,
          currentEnginePower - ENGINE_POWER_RATE * dt,
        );
      }
    }

    // –†–∞—Å—Ö–æ–¥ —Ç–æ–ø–ª–∏–≤–∞
    if (currentThrottle !== 0 && currentEnginePower !== 0) {
      const powerPercent = Math.abs(currentEnginePower);
      const { fuelRate } = interpolateFuelAndSpeed(powerPercent); // –ª/—á
      const fuelRatePerSec = fuelRate / 3600; // –ª/—Å
      const fuelUsed = fuelRatePerSec * dt;
      if (currentFuelReserve >= fuelUsed) {
        currentFuelReserve -= fuelUsed;
        fuelBurned += fuelUsed;
      } else {
        currentThrottle = 0;
        currentEnginePower = 0;
      }
    }

    // –°–∫–æ—Ä–æ—Å—Ç—å
    const { speed: targetSpeed } = interpolateFuelAndSpeed(
      Math.abs(currentEnginePower),
    );
    const sign = Math.sign(currentEnginePower);
    let finalTargetSpeed = sign * targetSpeed;

    if (Math.abs(currentSpeed - finalTargetSpeed) > 0.01) {
      let acceleration = 0.08;
      if (Math.abs(currentEnginePower) < 0.1) {
        acceleration = 0.3; // DECELERATION_COAST
      } else if (
        (currentEnginePower < 0 && currentSpeed > 0) ||
        (currentEnginePower > 0 && currentSpeed < 0)
      ) {
        acceleration = 0.8; // ACCELERATION_REVERSE
      }

      if (currentSpeed < finalTargetSpeed) {
        currentSpeed = Math.min(
          finalTargetSpeed,
          currentSpeed + acceleration * dt,
        );
      } else {
        currentSpeed = Math.max(
          finalTargetSpeed,
          currentSpeed - acceleration * dt,
        );
      }
    } else {
      currentSpeed = finalTargetSpeed;
    }

    if (Math.abs(currentEnginePower) < 0.1 && Math.abs(currentSpeed) > 0.1) {
      const drag = 0.3 * dt;
      if (currentSpeed > 0) {
        currentSpeed = Math.max(0, currentSpeed - drag);
      } else {
        currentSpeed = Math.min(0, currentSpeed + drag);
      }
    }

    // –ü–æ–≤–æ—Ä–æ—Ç
    if (Math.abs(currentSpeed) > 0.1) {
      const turnRate =
        MIN_TURN_RATE +
        (Math.abs(currentSpeed) / 135) * (MAX_TURN_RATE - MIN_TURN_RATE);
      const targetAngularVelocity = airshipData.rudder * turnRate;
      const angularAccel = 0.5;
      if (currentAngularVel < targetAngularVelocity) {
        currentAngularVel = Math.min(
          targetAngularVelocity,
          currentAngularVel + angularAccel * dt,
        );
      } else if (currentAngularVel > targetAngularVelocity) {
        currentAngularVel = Math.max(
          targetAngularVelocity,
          currentAngularVel - angularAccel * dt,
        );
      }
      currentHeading += currentAngularVel * dt;
      currentHeading = ((currentHeading % 360) + 360) % 360;
    } else {
      currentAngularVel *= 0.95;
      if (Math.abs(currentAngularVel) < 0.01) currentAngularVel = 0;
    }

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å —É—á—ë—Ç–æ–º –≤–µ—Ç—Ä–∞
    applyWindEffect();
    const groundSpeedKmh = airshipData.groundSpeed || Math.abs(currentSpeed);
    const distanceKm = (groundSpeedKmh * dt) / 3600;
    const distanceMeters = distanceKm * 1000;
    airshipData.totalDistanceMeters += distanceMeters;

    const headingRad = (currentHeading * Math.PI) / 180;
    const dx = distanceMeters * Math.sin(headingRad) * Math.sign(currentSpeed);
    const dy = distanceMeters * Math.cos(headingRad) * Math.sign(currentSpeed);
    const earthRadius = 6378137;
    currentLat += (dy / earthRadius) * (180 / Math.PI);
    currentLng +=
      ((dx / earthRadius) * (180 / Math.PI)) /
      Math.cos((currentLat * Math.PI) / 180);
  }

  airshipData.lat = currentLat;
  airshipData.lng = currentLng;
  airshipData.heading = currentHeading;
  airshipData.speed = currentSpeed;
  airshipData.angularVelocity = currentAngularVel;
  airshipData.propRotationAngle = currentPropAngle;
  airshipData.totalFuelBurned += fuelBurned;
  airshipData.fuelReserve = currentFuelReserve;
  airshipData.enginePower = currentEnginePower;
  airshipData.virtualElapsedSeconds += secondsToSkip;
  airshipData.lastUpdate = Date.now();

  if (airshipData.fuelReserve <= 0) {
    airshipData.throttle = 0;
    airshipData.enginePower = 0;
  }
}

// === –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò –ó–ê–ü–£–°–ö ===

function loadFuel() {
  const add = parseFloat(prompt("–°–∫–æ–ª—å–∫–æ –ª–∏—Ç—Ä–æ–≤ –¥–∏–∑–µ–ª—è –∑–∞–ø—Ä–∞–≤–∏—Ç—å?", "1000"));
  if (!isNaN(add) && add > 0) {
    airshipData.fuelReserve = Math.min(
      MAX_FUEL_CAPACITY,
      airshipData.fuelReserve + add,
    );
    updateStats();
    localStorage.setItem("airshipState", JSON.stringify(airshipData));
  }
}

let gameStarted = false;
let awaitingSpawn = false;
let awaitingTarget = false;

function spawnAirship(lat, lng) {
  if (gameStarted || !lat || !lng) return;
  gameStarted = true;
  awaitingSpawn = false;

  if (airshipMarker) map.removeLayer(airshipMarker);
  airshipMarker = L.marker([lat, lng], {
    icon: L.divIcon({ className: "" }),
  }).addTo(map);
  Object.assign(airshipData, {
    lat,
    lng,
    heading: 0,
    speed: 0,
    throttle: 0,
    rudder: 0,
    angularVelocity: 0,
    lastUpdate: Date.now(),
    propRotationAngle: 0,
    flagEnabled: false,
    followEnabled: false,
    autopilotEnabled: false,
    fastBrakeEnabled: false,
    startTime: Date.now(),
    totalDistanceMeters: 0,
    fuelReserve: 50000, // –Ω–∞—á–∞–ª—å–Ω—ã–π –∑–∞–ø–∞—Å
    totalFuelBurned: 0,
    hasTarget: false,
    targetLat: null,
    targetLng: null,
    virtualStartTime: Date.now(),
    enginePower: 0,
    engineReversing: false,
  });

  document.getElementById("controls").style.display = "flex";
  document.getElementById("toggleControlsBtn").style.display = "block";
  document.getElementById("stats").style.display = "block";
  document.getElementById("autopilotToggle").disabled = true;

  updateDisplays();
  updateAirshipIcon();
  updateFlag();
  updateStats();
  startAutoSave();
}

let autoSaveInterval = null;
function startAutoSave() {
  if (autoSaveInterval) clearInterval(autoSaveInterval);
  autoSaveInterval = setInterval(() => {
    if (airshipMarker) {
      localStorage.setItem("airshipState", JSON.stringify(airshipData));
    }
  }, 10000);
}

// === –ó–ê–ì–†–£–ó–ö–ê –ò–ó URL ===

function loadFromUrl() {
  try {
    const urlParams = new URLSearchParams(window.location.search);

    const lat = parseFloat(urlParams.get("lat"));
    const lng = parseFloat(urlParams.get("lng"));
    if (isNaN(lat) || isNaN(lng) || Math.abs(lat) > 90 || Math.abs(lng) > 180) {
      return false;
    }

    airshipData.lat = lat;
    airshipData.lng = lng;

    const safeFloat = (key, def) => {
      const val = parseFloat(urlParams.get(key));
      return isNaN(val) ? def : val;
    };
    const safeInt = (key, def) => {
      const val = parseInt(urlParams.get(key), 10);
      return isNaN(val) ? def : val;
    };
    const safeBool = (key) => urlParams.get(key) === "1";

    airshipData.heading = safeFloat("hdg", 0);
    airshipData.speed = safeFloat("spd", 0);
    airshipData.throttle = safeInt("thr", 0);
    airshipData.rudder = safeFloat("rud", 0);
    airshipData.enginePower = safeFloat("eng", 0);
    airshipData.hasTarget = safeBool("tgt");

    if (airshipData.hasTarget) {
      const tlt = safeFloat("tlt", NaN);
      const tlg = safeFloat("tlg", NaN);
      if (
        isNaN(tlt) ||
        isNaN(tlg) ||
        Math.abs(tlt) > 90 ||
        Math.abs(tlg) > 180
      ) {
        airshipData.hasTarget = false;
      } else {
        airshipData.targetLat = tlt;
        airshipData.targetLng = tlg;
      }
    }

    airshipData.autopilotEnabled = safeBool("apl");
    airshipData.fastBrakeEnabled = safeBool("fbr");

    const vst = safeInt("vst", 0);
    airshipData.virtualStartTime = vst > 0 ? vst * 1000 : Date.now();
    airshipData.startTime = Date.now(); // –≤—Å–µ–≥–¥–∞ —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è
    airshipData.lastUpdate = Date.now();

    if (airshipMarker) map.removeLayer(airshipMarker);
    airshipMarker = L.marker([lat, lng], {
      icon: L.divIcon({ className: "" }),
    }).addTo(map);

    if (airshipData.hasTarget) {
      setTarget(airshipData.targetLat, airshipData.targetLng);
    }

    updateAirshipIcon();
    updateDisplays();
    updateStats();
    startAutoSave();

    document.getElementById("controls").style.display = "flex";
    document.getElementById("toggleControlsBtn").style.display = "block";
    document.getElementById("stats").style.display = "block";

    gameStarted = true;
    awaitingSpawn = false;
    document.getElementById("start-menu").style.display = "none";
    return true;
  } catch (e) {
    console.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑ URL:", e);
    return false;
  }
}

// === –ó–ê–ì–†–£–ó–ö–ê –ò–ó LOCALSTORAGE ===

function loadSavedState() {
  try {
    const saved = localStorage.getItem("airshipState");
    const btnContinue = document.getElementById("btn-continue");
    if (saved) {
      const parsed = JSON.parse(saved);
      if (typeof parsed.lat === "number" && typeof parsed.lng === "number") {
        btnContinue.disabled = false;
        btnContinue.onclick = () => {
          try {
            document.getElementById("start-menu").style.display = "none";
            spawnAirship(parsed.lat, parsed.lng);
            Object.assign(airshipData, parsed);
            airshipData.startTime = Date.now(); // —Å–±—Ä–æ—Å –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–ª—ë—Ç–∞
            gameStarted = true;
            awaitingSpawn = false;

            document.getElementById("controls").style.display = "flex";
            document.getElementById("toggleControlsBtn").style.display =
              "block";
            document.getElementById("stats").style.display = "block";

            updateDisplays();
            updateAirshipIcon();
            if (airshipData.flagEnabled) {
              document.getElementById("flagToggle").checked = true;
              updateFlag();
            }
            if (airshipData.followEnabled) {
              document.getElementById("followToggle").checked = true;
            }
            if (airshipData.hasTarget) {
              setTarget(airshipData.targetLat, airshipData.targetLng);
            }
            focusOnAirship(12);
            startAutoSave();
          } catch (e) {
            console.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑ localStorage:", e);
            alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ.");
          }
        };
        return;
      }
    }
  } catch (e) {
    console.warn("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:", e);
  }
  document.getElementById("btn-continue").disabled = true;
}

// === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===

const timeWarpSlider = document.getElementById("timeWarpSlider");
const timeWarpValue = document.getElementById("timeWarpValue");
timeWarpSlider.addEventListener("input", () => {
  const index = parseInt(timeWarpSlider.value);
  timeWarpFactor = timeSteps[index];
  updateDisplays();
});

const zoomScaleSlider = document.getElementById("zoomScaleSlider");
const zoomScaleValue = document.getElementById("zoomScaleValue");
let zoomDebounceTimer = null;
zoomScaleSlider.addEventListener("input", () => {
  if (zoomDebounceTimer) clearTimeout(zoomDebounceTimer);
  currentZoomScaleIndex = parseInt(zoomScaleSlider.value);
  updateDisplays();
  zoomDebounceTimer = setTimeout(() => {
    const zoomLevel = ZOOM_SCALE_LEVELS[currentZoomScaleIndex];
    map.setZoom(zoomLevel);
    zoomDebounceTimer = null;
  }, 500);
});

document.getElementById("pauseBtn").addEventListener("click", () => {
  isPaused = !isPaused;
  updateDisplays();
  startAutoSave();
});

const rudderSlider = document.getElementById("rudderSlider");
const throttleSlider = document.getElementById("throttleSlider");
const rudderValue = document.getElementById("rudderValue");
const throttleValue = document.getElementById("throttleValue");

rudderSlider.addEventListener("input", () => {
  airshipData.autopilotEnabled = false;
  document.getElementById("autopilotToggle").checked = false;
  const sliderVal = parseInt(rudderSlider.value);
  airshipData.rudder = sliderVal * 0.1;
  rudderValue.textContent = airshipData.rudder.toFixed(1) + "¬∞";
});

throttleSlider.addEventListener("input", () => {
  airshipData.autopilotEnabled = false;
  document.getElementById("autopilotToggle").checked = false;
  airshipData.throttle = parseInt(throttleSlider.value);
  const throttleLabels = {
    "-5": "ASTERN FULL",
    "-4": "ASTERN HALF",
    "-3": "ASTERN SLOW",
    "-2": "ASTERN DEAD SLOW",
    "-1": "DEAD SLOW (astern)",
    0: "STOP",
    1: "DEAD SLOW",
    2: "SLOW",
    3: "HALF",
    4: "FULL",
    5: "FULL",
  };
  throttleValue.textContent = throttleLabels[airshipData.throttle] || "STOP";
});

document
  .getElementById("fastBrakeToggle")
  .addEventListener("change", function () {
    airshipData.fastBrakeEnabled = this.checked;
    if (airshipData.fastBrakeEnabled && airshipData.speed <= 5) {
      this.checked = false;
      airshipData.fastBrakeEnabled = false;
    }
  });

document.getElementById("flagToggle").addEventListener("change", function () {
  airshipData.flagEnabled = this.checked;
  updateFlag();
});

document.getElementById("followToggle").addEventListener("change", function () {
  airshipData.followEnabled = this.checked;
});

document
  .getElementById("autopilotToggle")
  .addEventListener("change", function () {
    airshipData.autopilotEnabled = this.checked;
    if (airshipData.autopilotEnabled && !airshipData.hasTarget) {
      this.checked = false;
      airshipData.autopilotEnabled = false;
      alert("–°–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ü–µ–ª—å!");
    }
  });

// === –í–ï–¢–ï–† ===

// –í–µ—Ç–µ—Ä: –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–≤
document.querySelectorAll('input[name="windMode"]').forEach((radio) => {
  radio.addEventListener("change", () => {
    windMode = radio.value;
    document.getElementById("manualWindInputs").style.display =
      windMode === "manual" ? "block" : "none";
  });
});

// –í–µ—Ç–µ—Ä: —Ä—É—á–Ω–æ–π –≤–≤–æ–¥
document.getElementById("windSpeedInput").addEventListener("input", () => {
  windSpeedBf =
    parseFloat(document.getElementById("windSpeedInput").value) || 0;
  windSpeedBf = Math.max(0, Math.min(12, windSpeedBf));
});

document.getElementById("windDirectionInput").addEventListener("input", () => {
  windDirection =
    parseFloat(document.getElementById("windDirectionInput").value) || 0;
  windDirection = ((windDirection % 360) + 360) % 360;
});

// === –ö–ù–û–ü–ö–ò ===
document.getElementById("focusBtn").addEventListener("click", () => {
  focusOnAirship(12);
});

document.getElementById("targetBtn").addEventListener("click", () => {
  if (airshipData.hasTarget) {
    removeTarget();
  } else {
    awaitingTarget = true;
    alert("–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ—á–∫—É –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è.");
  }
});

document.getElementById("fuelBtn").addEventListener("click", loadFuel);

document.getElementById("newGameBtn").addEventListener("click", () => {
  if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã? –¢–µ–∫—É—â–∏–π –ø–æ–ª—ë—Ç –±—É–¥–µ—Ç —Å–±—Ä–æ—à–µ–Ω.")) {
    window.history.replaceState(null, "", window.location.pathname);
    location.reload();
  }
});

document.getElementById("toggleControlsBtn").addEventListener("click", () => {
  const controls = document.getElementById("controls");
  const btn = document.getElementById("toggleControlsBtn");
  if (controls.style.display === "none") {
    controls.style.display = "flex";
    btn.textContent = "^";
  } else {
    controls.style.display = "none";
    btn.textContent = "‚åÑ";
  }
});

// === –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ ===

function simulateStep() {
  if (!airshipMarker || isPaused) return;

  const now = Date.now();
  const dtReal = (now - airshipData.lastUpdate) / 1000;
  const dtSimulated = dtReal * timeWarpFactor;
  airshipData.virtualElapsedSeconds += dtSimulated;
  airshipData.lastUpdate = now;

  if (windMode === "auto") {
    const nowMs = Date.now();
    if (!airshipData.windLastUpdate) airshipData.windLastUpdate = nowMs;
    if (nowMs - airshipData.windLastUpdate > 30000) {
      // –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫
      windSpeedBf += (Math.random() - 0.5) * 0.5;
      windDirection += (Math.random() - 0.5) * 10;
      windSpeedBf = Math.max(0, Math.min(12, windSpeedBf));
      windDirection = ((windDirection % 360) + 360) % 360;
      airshipData.windLastUpdate = nowMs;
    }
  }

  if (airshipData.fastBrakeEnabled && airshipData.speed > 5) {
    airshipData.throttle = -5;
  } else if (airshipData.speed <= 5 && airshipData.fastBrakeEnabled) {
    airshipData.fastBrakeEnabled = false;
    document.getElementById("fastBrakeToggle").checked = false;
    airshipData.throttle = 0;
  }

  if (airshipData.autopilotEnabled) {
    runAutopilot();
  }

  const currentSign = Math.sign(airshipData.enginePower);
  const targetSign = Math.sign(airshipData.throttle);

  if (currentSign !== targetSign && airshipData.enginePower !== 0) {
    if (airshipData.enginePower > 0) {
      airshipData.enginePower = Math.max(
        0,
        airshipData.enginePower - ENGINE_POWER_RATE * dtSimulated,
      );
    } else {
      airshipData.enginePower = Math.min(
        0,
        airshipData.enginePower + ENGINE_POWER_RATE * dtSimulated,
      );
    }
    if (Math.abs(airshipData.enginePower) <= 0.1) {
      airshipData.enginePower = 0;
    }
  } else {
    const targetEnginePower = airshipData.throttle * 20;
    if (airshipData.enginePower < targetEnginePower) {
      airshipData.enginePower = Math.min(
        targetEnginePower,
        airshipData.enginePower + ENGINE_POWER_RATE * dtSimulated,
      );
    } else if (airshipData.enginePower > targetEnginePower) {
      airshipData.enginePower = Math.max(
        targetEnginePower,
        airshipData.enginePower - ENGINE_POWER_RATE * dtSimulated,
      );
    }
  }

  let fuelUsed = 0;
  if (
    airshipData.throttle !== 0 &&
    airshipData.enginePower !== 0 &&
    airshipData.fuelReserve > 0
  ) {
    const powerPercent = Math.abs(airshipData.enginePower);
    const { fuelRate } = interpolateFuelAndSpeed(powerPercent); // –ª/—á
    const fuelRatePerSec = fuelRate / 3600; // –ª/—Å
    fuelUsed = fuelRatePerSec * dtSimulated;
    if (airshipData.fuelReserve >= fuelUsed) {
      airshipData.fuelReserve -= fuelUsed;
      airshipData.totalFuelBurned += fuelUsed;
    } else {
      airshipData.fuelReserve = 0;
      airshipData.throttle = 0;
      airshipData.enginePower = 0;
    }
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
  const { speed: targetSpeed } = interpolateFuelAndSpeed(
    Math.abs(airshipData.enginePower),
  );
  const sign = Math.sign(airshipData.enginePower);
  let finalTargetSpeed = sign * targetSpeed;

  if (Math.abs(airshipData.speed - finalTargetSpeed) > 0.01) {
    let acceleration = 0.08;
    if (Math.abs(airshipData.enginePower) < 0.1) {
      acceleration = 0.3;
    } else if (
      (airshipData.enginePower < 0 && airshipData.speed > 0) ||
      (airshipData.enginePower > 0 && airshipData.speed < 0)
    ) {
      acceleration = 0.8;
    }

    if (airshipData.speed < finalTargetSpeed) {
      airshipData.speed = Math.min(
        finalTargetSpeed,
        airshipData.speed + acceleration * dtSimulated,
      );
    } else {
      airshipData.speed = Math.max(
        finalTargetSpeed,
        airshipData.speed - acceleration * dtSimulated,
      );
    }
  } else {
    airshipData.speed = finalTargetSpeed;
  }

  if (
    Math.abs(airshipData.enginePower) < 0.1 &&
    Math.abs(airshipData.speed) > 0.1
  ) {
    const drag = 0.3 * dtSimulated;
    if (airshipData.speed > 0) {
      airshipData.speed = Math.max(0, airshipData.speed - drag);
    } else {
      airshipData.speed = Math.min(0, airshipData.speed + drag);
    }
  }

  // –ü–æ–≤–æ—Ä–æ—Ç
  if (Math.abs(airshipData.speed) > 0.1) {
    const turnRate =
      MIN_TURN_RATE +
      (Math.abs(airshipData.speed) / 135) * (MAX_TURN_RATE - MIN_TURN_RATE);
    const targetAngularVelocity = airshipData.rudder * turnRate;
    const angularAccel = 0.5;
    if (airshipData.angularVelocity < targetAngularVelocity) {
      airshipData.angularVelocity = Math.min(
        targetAngularVelocity,
        airshipData.angularVelocity + angularAccel * dtSimulated,
      );
    } else if (airshipData.angularVelocity > targetAngularVelocity) {
      airshipData.angularVelocity = Math.max(
        targetAngularVelocity,
        airshipData.angularVelocity - angularAccel * dtSimulated,
      );
    }
    airshipData.heading += airshipData.angularVelocity * dtSimulated;
    airshipData.heading = ((airshipData.heading % 360) + 360) % 360;
  } else {
    airshipData.angularVelocity *= 0.95;
    if (Math.abs(airshipData.angularVelocity) < 0.01)
      airshipData.angularVelocity = 0;
  }

  // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å —É—á—ë—Ç–æ–º –≤–µ—Ç—Ä–∞
  applyWindEffect();
  const groundSpeedKmh = airshipData.groundSpeed || Math.abs(airshipData.speed);
  const distanceKm = (groundSpeedKmh * dtSimulated) / 3600;
  const distanceMeters = distanceKm * 1000;
  airshipData.totalDistanceMeters += distanceMeters;

  const headingRad = (airshipData.heading * Math.PI) / 180;
  const dx =
    distanceMeters * Math.sin(headingRad) * Math.sign(airshipData.speed);
  const dy =
    distanceMeters * Math.cos(headingRad) * Math.sign(airshipData.speed);
  const earthRadius = 6378137;
  const newLat = airshipData.lat + (dy / earthRadius) * (180 / Math.PI);
  const newLng =
    airshipData.lng +
    ((dx / earthRadius) * (180 / Math.PI)) /
      Math.cos((airshipData.lat * Math.PI) / 180);
  airshipData.lat = newLat;
  airshipData.lng = newLng;
  airshipMarker.setLatLng([newLat, newLng]);
  if (flagMarker) flagMarker.setLatLng([newLat, newLng]);

  if (airshipData.followEnabled) {
    map.panTo([newLat, newLng], { animate: false });
  }

  if (airshipData.hasTarget) {
    updateDirectionArrow();
  }

  updateDisplays();
  updateAirshipIcon();
  updateStats();
  updateUrl();
}

map.on("click", (e) => {
  if (awaitingSpawn) {
    spawnAirship(e.latlng.lat, e.latlng.lng);
  } else if (awaitingTarget) {
    awaitingTarget = false;
    setTarget(e.latlng.lat, e.latlng.lng);
  }
});

map.on("zoomend", () => {
  if (airshipMarker) updateAirshipIcon();
});

document.getElementById("btn-new").onclick = () => {
  document.getElementById("start-menu").style.display = "none";
  awaitingSpawn = true;
};

if (!loadFromUrl()) {
  loadSavedState();
}

setInterval(simulateStep, 50);
