<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–°–∏–º—É–ª—è—Ç–æ—Ä –¥–∏—Ä–∏–∂–∞–±–ª—è ¬´–ì–∏—Ç—ç–Ω—é—É—Ä–≥¬ª</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, sans-serif;
        background: #000;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      #start-menu {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        color: white;
      }

      #start-menu h1 {
        font-size: 28px;
        margin-bottom: 30px;
        color: #4fc3f7;
      }

      #start-menu button {
        padding: 12px 30px;
        font-size: 18px;
        margin: 10px;
        background: #1e88e5;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
      }

      #start-menu button:hover {
        background: #1976d2;
      }

      #start-menu button:disabled {
        background: #555;
        cursor: not-allowed;
      }

      #controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px;
        display: none;
        justify-content: space-around;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        z-index: 1000;
        pointer-events: auto;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
        min-width: 120px;
      }

      .slider {
        width: 100px;
        margin: 5px 0;
      }

      .label {
        font-size: 13px;
        margin-top: 4px;
        color: #aaa;
      }

      .value-display {
        font-size: 16px;
        font-weight: bold;
        color: #0ff;
        margin-top: 2px;
      }

      .speed-display {
        font-size: 18px;
        font-weight: bold;
        color: #0f0;
      }

      .flag-control {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .skip-control {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
      }

      .skip-input {
        width: 80px;
        padding: 4px;
        text-align: center;
        font-size: 14px;
      }

      .skip-btn,
      .offline-btn,
      .coal-btn,
      .pause-btn {
        margin-top: 4px;
        padding: 4px 10px;
        font-size: 12px;
        background: #555;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }

      .skip-btn:hover,
      .offline-btn:hover,
      .coal-btn:hover,
      .pause-btn:hover {
        background: #777;
      }

      #toggleControlsBtn {
        position: fixed;
        bottom: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        z-index: 1001;
        display: none;
      }

      #stats {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        z-index: 1001;
        pointer-events: none;
      }

      .leaflet-div-icon {
        overflow: visible !important;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="start-menu">
      <h1>–°–∏–º—É–ª—è—Ç–æ—Ä –¥–∏—Ä–∏–∂–∞–±–ª—è ¬´–ì–∏—Ç—ç–Ω—é—É—Ä–≥¬ª</h1>
      <button id="btn-new">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>
      <button id="btn-continue" disabled>–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>

    <div id="controls">
      <div class="control-group">
        <input
          type="range"
          min="-5"
          max="5"
          value="0"
          step="1"
          class="slider"
          id="rudderSlider"
        />
        <div class="value-display" id="rudderValue">0.0¬∞</div>
        <div class="label">–®—Ç—É—Ä–≤–∞–ª (¬±0.5¬∞)</div>
      </div>

      <div class="control-group">
        <input
          type="range"
          min="-5"
          max="5"
          value="0"
          step="1"
          class="slider"
          id="throttleSlider"
        />
        <div class="value-display" id="throttleValue">STOP</div>
        <div class="label">–ú–æ—â–Ω–æ—Å—Ç—å –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π</div>
      </div>

      <div class="control-group">
        <label
          ><input type="checkbox" id="fastBrakeToggle" /> –ë—ã—Å—Ç—Ä–æ–µ
          —Ç–æ—Ä–º–æ–∂–µ–Ω–∏–µ</label
        >
      </div>

      <div class="control-group">
        <div class="speed-display" id="speedometer">0 –∫–º/—á</div>
        <div class="label">–°–∫–æ—Ä–æ—Å—Ç—å</div>
      </div>

      <div class="control-group">
        <div class="value-display" id="enginePowerDisplay">0%</div>
        <div class="label">–ú–æ—â–Ω–æ—Å—Ç—å –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π</div>
      </div>

      <div class="control-group">
        <div class="value-display" id="compass">0¬∞ (0¬∞)</div>
        <div class="label">–ö—É—Ä—Å (–æ—Ç–∫–ª.)</div>
      </div>

      <div class="control-group">
        <input
          type="range"
          id="timeWarpSlider"
          class="slider"
          min="0"
          max="14"
          step="1"
          value="1"
        />
        <div class="value-display" id="timeWarpValue">1x</div>
        <div class="label">–£—Å–∫–æ—Ä–µ–Ω–∏–µ</div>
      </div>

      <div class="control-group">
        <input
          type="range"
          id="zoomScaleSlider"
          class="slider"
          min="0"
          max="7"
          step="1"
          value="7"
        />
        <div class="value-display" id="zoomScaleValue">1x</div>
        <div class="label">–ú–∞—Å—à—Ç–∞–±</div>
      </div>

      <div class="control-group">
        <button id="pauseBtn" class="pause-btn">‚è∏Ô∏è</button>
        <div class="label">–ü–∞—É–∑–∞</div>
      </div>

      <div class="control-group flag-control">
        <label><input type="checkbox" id="flagToggle" /> –§–ª–∞–≥</label>
        <label><input type="checkbox" id="followToggle" /> –°–ª–µ–¥–æ–≤–∞—Ç—å</label>
        <label><input type="checkbox" id="autopilotToggle" /> –ê–≤—Ç–æ–ø–∏–ª–æ—Ç</label>
        <button id="focusBtn">–ö –¥–∏—Ä–∏–∂–∞–±–ª—é</button>
        <button id="targetBtn">–î–æ–±–∞–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä</button>
        <button id="syncTimeBtn">‚è±Ô∏è –°–∏–Ω—Ö—Ä.</button>
        <button id="coalBtn" class="coal-btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å —É–≥–æ–ª—å</button>
        <button id="newGameBtn">üÜï –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
      </div>
    </div>

    <button id="toggleControlsBtn">^</button>

    <div id="stats">
      –ü—Ä–æ–π–¥–µ–Ω–æ: 0 –∫–º 0 –º<br />–£–≥–æ–ª—å: 0.000 / 0.000 –∫–≥<br />–í—Ä–µ–º—è –≤ –ø—É—Ç–∏:
      00:00:00
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
      const map = L.map("map").setView([55.75, 37.62], 4);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      let airshipMarker = null;
      let flagMarker = null;
      let targetMarker = null;
      let directionArrow = null;

      const timeSteps = [
        0.1, // 0
        1, // 1
        2, // 2
        5, // 3
        10, // 4
        20, // 5
        30, // 6
        40, // 7
        50, // 8
        60, // 9
        70, // 10
        80, // 11
        90, // 12
        100, // 13
        1000, // 14
      ];
      let timeWarpFactor = 1;
      let isPaused = false;

      const MAX_COAL_RESERVE = 900000;
      const COAL_CONSUMPTION_RATE = 0.001;
      // üî• –ú–ê–°–®–¢–ê–ë: —Ç–µ–ø–µ—Ä—å 0 = –¥–∞–ª–µ–∫–æ, 7 = –±–ª–∏–∑–∫–æ
      const ZOOM_SCALE_LEVELS = [2, 4, 6, 8, 9, 10, 11, 15]; // 1000x ‚Üí 1x
      let currentZoomScaleIndex = 7; // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1x (zoom=12)

      const ENGINE_POWER_RATE = 1.0;
      const MAX_SPEED = 135;
      const ACCELERATION_FORWARD = 0.08;
      const ACCELERATION_REVERSE = 0.8;
      const DECELERATION_COAST = 0.3;
      const MAX_TURN_RATE = 3;
      const MIN_TURN_RATE = 0.3;
      const PROPELLER_BASE_SCALE = 4.0;

      let airshipData = {
        lat: 0,
        lng: 0,
        heading: 0,
        speed: 0,
        throttle: 0,
        rudder: 0,
        angularVelocity: 0,
        lastUpdate: Date.now(),
        propRotationAngle: 0,
        flagEnabled: false,
        followEnabled: false,
        autopilotEnabled: false,
        fastBrakeEnabled: false,
        startTime: null,
        totalDistanceMeters: 0,
        coalReserve: 0,
        totalCoalBurned: 0,
        hasTarget: false,
        targetLat: null,
        targetLng: null,
        virtualElapsedSeconds: 0,
        virtualStartTime: null,
        enginePower: 0,
        engineReversing: false,
      };

      const throttleLabels = {
        "-5": "ASTERN FULL",
        "-4": "ASTERN HALF",
        "-3": "ASTERN SLOW",
        "-2": "ASTERN DEAD SLOW",
        "-1": "DEAD SLOW (astern)",
        0: "STOP",
        1: "DEAD SLOW",
        2: "SLOW",
        3: "HALF",
        4: "FULL",
        5: "FULL",
      };

      function calculatePropellerRPM() {
        if (
          Math.abs(airshipData.enginePower) < 0.1 ||
          airshipData.coalReserve <= 0
        )
          return 0;
        return (airshipData.enginePower * 3 * PROPELLER_BASE_SCALE) / 20;
      }

      const flagIcon = L.divIcon({
        className: "",
        html: "üö©",
        iconSize: [20, 24],
        iconAnchor: [10, 24],
      });

      const targetIcon = L.divIcon({
        className: "",
        html: "üéØ",
        iconSize: [24, 24],
        iconAnchor: [12, 12],
      });

      function getAirshipSvg(zoom, heading, propRotationAngle) {
        if (zoom <= 8) {
          return `<svg viewBox="0 0 10 10" width="10" height="10">
                <circle cx="5" cy="5" r="4" fill="#ff3300" stroke="#000" stroke-width="1"/>
              </svg>`;
        }

        const metersPerPixel =
          (156543.03392 * Math.cos((airshipData.lat * Math.PI) / 180)) /
          Math.pow(2, zoom);
        const lengthPx = 500 / metersPerPixel;
        const widthPx = lengthPx * 0.22;

        const propSize = widthPx * 0.3;
        const centerY = lengthPx * 0.92;
        const offsetX = widthPx * 0.15;
        const leftPropX = widthPx / 2 - offsetX;
        const rightPropX = widthPx / 2 + offsetX;

        return `
      <svg viewBox="0 0 ${widthPx} ${lengthPx}" 
           width="${widthPx}" height="${lengthPx}"
           style="transform: rotate(${heading}deg); transform-origin: center;">
        <ellipse cx="${widthPx / 2}" cy="${lengthPx / 2}" 
                 rx="${widthPx / 2}" ry="${lengthPx / 2}" 
                 fill="#3a5ca0" stroke="#1a3a6a" stroke-width="1"/>
        <image href="https://cdn-icons-png.flaticon.com/512/166/166062.png"
               x="${leftPropX - propSize / 2}" y="${centerY - propSize / 2}"
               width="${propSize}" height="${propSize}"
               transform="rotate(${propRotationAngle} ${leftPropX} ${centerY})" />
        <image href="https://cdn-icons-png.flaticon.com/512/166/166062.png"
               x="${rightPropX - propSize / 2}" y="${centerY - propSize / 2}"
               width="${propSize}" height="${propSize}"
               transform="rotate(${-propRotationAngle} ${rightPropX} ${centerY})" />
      </svg>`;
      }

      function updateAirshipIcon() {
        if (!airshipMarker) return;
        const zoom = map.getZoom();
        const svgHtml = getAirshipSvg(
          zoom,
          airshipData.heading,
          airshipData.propRotationAngle,
        );
        const newIcon = L.divIcon({
          className: "",
          html: svgHtml,
          iconSize: null,
        });
        airshipMarker.setIcon(newIcon);
      }

      function updateFlag() {
        const showFlag = document.getElementById("flagToggle").checked;
        if (showFlag && airshipMarker) {
          if (!flagMarker) {
            flagMarker = L.marker([airshipData.lat, airshipData.lng], {
              icon: flagIcon,
            }).addTo(map);
          } else {
            flagMarker.setLatLng([airshipData.lat, airshipData.lng]);
          }
        } else {
          if (flagMarker) {
            map.removeLayer(flagMarker);
            flagMarker = null;
          }
        }
      }

      function setTarget(lat, lng) {
        airshipData.hasTarget = true;
        airshipData.targetLat = lat;
        airshipData.targetLng = lng;
        if (targetMarker) map.removeLayer(targetMarker);
        targetMarker = L.marker([lat, lng], { icon: targetIcon }).addTo(map);
        document.getElementById("targetBtn").textContent = "–£–¥–∞–ª–∏—Ç—å –º–∞—Ä–∫–µ—Ä";
        document.getElementById("autopilotToggle").disabled = false;
        updateDirectionArrow();
      }

      function removeTarget() {
        airshipData.hasTarget = false;
        airshipData.targetLat = null;
        airshipData.targetLng = null;
        if (targetMarker) {
          map.removeLayer(targetMarker);
          targetMarker = null;
        }
        if (directionArrow) {
          map.removeLayer(directionArrow);
          directionArrow = null;
        }
        document.getElementById("targetBtn").textContent = "–î–æ–±–∞–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä";
        document.getElementById("autopilotToggle").checked = false;
        document.getElementById("autopilotToggle").disabled = true;
        airshipData.autopilotEnabled = false;
      }

      function updateDirectionArrow() {
        if (!airshipData.hasTarget || !airshipMarker) return;
        if (directionArrow) map.removeLayer(directionArrow);

        const R = 6378137;
        const lat1 = (airshipData.lat * Math.PI) / 180;
        const lon1 = (airshipData.lng * Math.PI) / 180;
        const lat2 = (airshipData.targetLat * Math.PI) / 180;
        const lon2 = (airshipData.targetLng * Math.PI) / 180;

        const dLon = lon2 - lon1;
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const bearing = ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;

        const dx = R * Math.cos(lat1) * Math.sin(dLon);
        const dy = R * (Math.sin(lat2) - Math.sin(lat1));
        const distance = Math.sqrt(dx * dx + dy * dy);

        let timeToTargetText = "~ ‚àû";
        if (Math.abs(airshipData.speed) > 5) {
          const speedMs = Math.abs(airshipData.speed) / 3.6;
          const seconds = distance / speedMs;
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          if (hours > 0) {
            timeToTargetText = `~ ${hours} —á. ${minutes} –º–∏–Ω.`;
          } else {
            timeToTargetText = `~ ${minutes} –º–∏–Ω.`;
          }
        }

        const arrowLength = 60;
        const arrowRad = ((bearing - 90) * Math.PI) / 180;
        const arrowEndX = arrowLength * Math.cos(arrowRad);
        const arrowEndY = arrowLength * Math.sin(arrowRad);

        const kmInt = Math.floor(distance / 1000);
        const kmText = kmInt.toString().padStart(4, "0") + " –∫–º";

        const size = 200;
        const centerX = size / 2;
        const centerY = size / 2;

        const arrowSvg = `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="overflow:visible;">
        <line x1="${centerX}" y1="${centerY}" 
              x2="${centerX + arrowEndX}" y2="${centerY + arrowEndY}" 
              stroke="#000" stroke-width="3" marker-end="url(#arrowhead)"/>
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#000"/>
          </marker>
        </defs>
        <rect x="${centerX + arrowEndX + 5}" y="${centerY + arrowEndY - 36}" 
              width="80" height="36" rx="5" ry="5" fill="#000" />
        <text x="${centerX + arrowEndX + 45}" y="${centerY + arrowEndY - 20}" 
              fill="#fff" font-size="12" text-anchor="middle" font-family="Arial">
          ${kmText}
        </text>
        <text x="${centerX + arrowEndX + 45}" y="${centerY + arrowEndY - 5}" 
              fill="#fff" font-size="11" text-anchor="middle" font-family="Arial">
          ${timeToTargetText}
        </text>
      </svg>`;

        const arrowIcon = L.divIcon({
          className: "",
          html: arrowSvg,
          iconSize: [size, size],
          iconAnchor: [centerX, centerY],
        });

        directionArrow = L.marker([airshipData.lat, airshipData.lng], {
          icon: arrowIcon,
        }).addTo(map);
      }

      function focusOnAirship(optimalZoom = 12) {
        if (airshipMarker) {
          map.setView([airshipData.lat, airshipData.lng], optimalZoom);
        }
      }

      function formatDistance(meters) {
        const km = Math.floor(meters / 1000);
        const m = Math.floor(meters % 1000);
        return `${km} –∫–º ${m} –º`;
      }

      function formatCoal(kg) {
        return kg.toFixed(3);
      }

      function formatVirtualDateTime(totalSeconds) {
        const start = new Date(airshipData.virtualStartTime);
        const virtualTime = new Date(start.getTime() + totalSeconds * 1000);
        const dateStr = virtualTime.toLocaleDateString("ru-RU");
        const timeStr = virtualTime.toTimeString().slice(0, 8);
        return `${dateStr} ${timeStr}`;
      }

      // üî• –†–∞—Å—á—ë—Ç –≤—Ä–µ–º–µ–Ω–∏ —É–≥–ª—è
      function calculateCoalTimeRemaining() {
        if (airshipData.coalReserve <= 0) return "00:00";
        const powerPercent = Math.abs(airshipData.enginePower);
        if (powerPercent < 0.1) return "‚àû"; // –≤–µ—á–Ω–æ—Å—Ç—å

        const consumptionPerSecond =
          (powerPercent * COAL_CONSUMPTION_RATE) / 60; // –∫–≥/—Å
        const seconds = airshipData.coalReserve / consumptionPerSecond;

        if (seconds > 24 * 3600) return "‚àû";

        const h = Math.floor(seconds / 3600)
          .toString()
          .padStart(2, "0");
        const m = Math.floor((seconds % 3600) / 60)
          .toString()
          .padStart(2, "0");
        return `${h}:${m}`;
      }

      function updateStats() {
        let timeDiffText = "00:00";
        if (airshipData.virtualStartTime) {
          const realElapsedMs = Date.now() - airshipData.virtualStartTime;
          const virtualElapsedMs = airshipData.virtualElapsedSeconds * 1000;
          const diffMs = realElapsedMs - virtualElapsedMs;

          if (Math.abs(diffMs) >= 1000) {
            const totalSec = Math.floor(Math.abs(diffMs) / 1000);
            const h = Math.floor(totalSec / 3600)
              .toString()
              .padStart(2, "0");
            const m = Math.floor((totalSec % 3600) / 60)
              .toString()
              .padStart(2, "0");
            const sign = diffMs > 0 ? "+" : "-";
            timeDiffText = `${sign}${h}:${m}`;
          }
        }

        const coalTime = calculateCoalTimeRemaining();
        document.getElementById("stats").innerHTML =
          `–ü—Ä–æ–π–¥–µ–Ω–æ: ${formatDistance(airshipData.totalDistanceMeters)}<br>` +
          `–£–≥–æ–ª—å: ${formatCoal(airshipData.totalCoalBurned)} / ${formatCoal(airshipData.coalReserve)} –∫–≥ (${coalTime})<br>` +
          `–í—Ä–µ–º—è: ${formatVirtualDateTime(airshipData.virtualElapsedSeconds)}<br>` +
          `–†–∞–∑–Ω–∏—Ü–∞: ${timeDiffText}`;
      }

      function updateDisplays() {
        rudderSlider.value = Math.round(airshipData.rudder * 10);
        throttleSlider.value = airshipData.throttle;
        rudderValue.textContent = airshipData.rudder.toFixed(1) + "¬∞";
        throttleValue.textContent =
          throttleLabels[airshipData.throttle] || "STOP";
        document.getElementById("speedometer").textContent =
          airshipData.speed.toFixed(1) + " –∫–º/—á";
        const sign = airshipData.enginePower >= 0 ? "" : "-";
        document.getElementById("enginePowerDisplay").textContent =
          sign + Math.abs(Math.round(airshipData.enginePower)) + "%";

        let courseDeviation = 0;
        if (airshipData.hasTarget) {
          const R = 6378137;
          const lat1 = (airshipData.lat * Math.PI) / 180;
          const lon1 = (airshipData.lng * Math.PI) / 180;
          const lat2 = (airshipData.targetLat * Math.PI) / 180;
          const lon2 = (airshipData.targetLng * Math.PI) / 180;
          const dLon = lon2 - lon1;
          const y = Math.sin(dLon) * Math.cos(lat2);
          const x =
            Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          const bearingToTarget =
            ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;
          courseDeviation = bearingToTarget - airshipData.heading;
          if (courseDeviation > 180) courseDeviation -= 360;
          if (courseDeviation < -180) courseDeviation += 360;
        }
        document.getElementById("compass").textContent =
          `${Math.round(airshipData.heading)}¬∞ (${Math.abs(Math.round(courseDeviation))}¬∞)`;

        document.getElementById("timeWarpValue").textContent =
          timeWarpFactor + "x";
        const zoomLabels = [
          "1000x",
          "500x",
          "200x",
          "100x",
          "10x",
          "5x",
          "2x",
          "1x",
        ].reverse();
        document.getElementById("zoomScaleValue").textContent =
          zoomLabels[currentZoomScaleIndex];
        document.getElementById("pauseBtn").textContent = isPaused
          ? "‚ñ∂Ô∏è"
          : "‚è∏Ô∏è";
        document.getElementById("autopilotToggle").checked =
          airshipData.autopilotEnabled;
        document.getElementById("fastBrakeToggle").checked =
          airshipData.fastBrakeEnabled;
      }

      let lastUrlUpdate = 0;
      function updateUrl() {
        const now = Date.now();
        if (now - lastUrlUpdate < 1000) return;
        lastUrlUpdate = now;

        const url = new URL(window.location);
        url.searchParams.set("lat", airshipData.lat.toFixed(6));
        url.searchParams.set("lng", airshipData.lng.toFixed(6));
        url.searchParams.set("hdg", airshipData.heading.toFixed(1));
        url.searchParams.set("spd", airshipData.speed.toFixed(1));
        url.searchParams.set("thr", airshipData.throttle);
        url.searchParams.set("rud", airshipData.rudder.toFixed(1));
        url.searchParams.set("eng", airshipData.enginePower.toFixed(1));
        url.searchParams.set("crl", airshipData.coalReserve.toFixed(3));
        url.searchParams.set("cbn", airshipData.totalCoalBurned.toFixed(3));
        url.searchParams.set("tgt", airshipData.hasTarget ? "1" : "0");
        if (airshipData.hasTarget) {
          url.searchParams.set("tlt", airshipData.targetLat.toFixed(6));
          url.searchParams.set("tlg", airshipData.targetLng.toFixed(6));
        }
        url.searchParams.set("apl", airshipData.autopilotEnabled ? "1" : "0");
        url.searchParams.set("fbr", airshipData.fastBrakeEnabled ? "1" : "0");
        url.searchParams.set(
          "vst",
          Math.floor(airshipData.virtualStartTime / 1000),
        );
        url.searchParams.set(
          "vel",
          airshipData.virtualElapsedSeconds.toFixed(1),
        );
        window.history.replaceState(null, "", url);
      }

      function runAutopilot() {
        if (
          !airshipData.hasTarget ||
          !airshipData.autopilotEnabled ||
          airshipData.coalReserve <= 0
        )
          return;

        const R = 6378137;
        const lat1 = (airshipData.lat * Math.PI) / 180;
        const lon1 = (airshipData.lng * Math.PI) / 180;
        const lat2 = (airshipData.targetLat * Math.PI) / 180;
        const lon2 = (airshipData.targetLng * Math.PI) / 180;

        const dLon = lon2 - lon1;
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const bearingToTarget =
          ((Math.atan2(y, x) * 180) / Math.PI + 360) % 360;

        const dx = R * Math.cos(lat1) * Math.sin(dLon);
        const dy = R * (Math.sin(lat2) - Math.sin(lat1));
        const distanceToTarget = Math.sqrt(dx * dx + dy * dy);

        let headingError = bearingToTarget - airshipData.heading;
        if (headingError > 180) headingError -= 360;
        if (headingError < -180) headingError += 360;

        let rudderCommand = headingError * 0.01;
        rudderCommand = Math.max(-0.5, Math.min(0.5, rudderCommand));
        airshipData.rudder = rudderCommand;

        const speedMs = airshipData.speed / 3.6;
        const decel = ACCELERATION_REVERSE / 3.6;
        const brakingDistance = (speedMs * speedMs) / (2 * decel);

        let throttleCommand = 0;
        if (distanceToTarget < 100) {
          throttleCommand = 0;
        } else if (distanceToTarget < brakingDistance + 500) {
          throttleCommand = -5;
        } else {
          throttleCommand = 5;
        }

        airshipData.throttle = Math.round(throttleCommand);
        document.getElementById("rudderSlider").value = Math.round(
          rudderCommand * 10,
        );
        document.getElementById("throttleSlider").value = airshipData.throttle;
      }

      function skipSimulationTime(secondsToSkip) {
        if (!airshipMarker || secondsToSkip <= 0) return;

        const simulatedSeconds = secondsToSkip * timeWarpFactor;

        let currentLat = airshipData.lat;
        let currentLng = airshipData.lng;
        let currentHeading = airshipData.heading;
        let currentSpeed = airshipData.speed;
        let currentAngularVel = airshipData.angularVelocity;
        let currentPropAngle = airshipData.propRotationAngle;
        let coalBurned = 0;
        let currentEnginePower = airshipData.enginePower;
        let currentCoalReserve = airshipData.coalReserve;
        let currentThrottle = airshipData.throttle;

        let remaining = simulatedSeconds;
        const step = 1;
        while (remaining > 0 && currentCoalReserve > 0) {
          const dt = Math.min(step, remaining);
          remaining -= dt;

          if (airshipData.fastBrakeEnabled && currentSpeed > 5) {
            currentThrottle = -5;
          } else if (currentSpeed <= 5 && airshipData.fastBrakeEnabled) {
            airshipData.fastBrakeEnabled = false;
            currentThrottle = 0;
          }

          if (airshipData.autopilotEnabled && airshipData.hasTarget) {
            const R = 6378137;
            const lat1 = (currentLat * Math.PI) / 180;
            const lon1 = (currentLng * Math.PI) / 180;
            const lat2 = (airshipData.targetLat * Math.PI) / 180;
            const lon2 = (airshipData.targetLng * Math.PI) / 180;
            const dLon = lon2 - lon1;
            const dx = R * Math.cos(lat1) * Math.sin(dLon);
            const dy = R * (Math.sin(lat2) - Math.sin(lat1));
            const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
            const speedMs = Math.abs(currentSpeed) / 3.6;
            const decel = ACCELERATION_REVERSE / 3.6;
            const brakingDistance = (speedMs * speedMs) / (2 * decel);
            if (distanceToTarget < 100) {
              currentThrottle = 0;
            } else if (distanceToTarget < brakingDistance + 500) {
              currentThrottle = -5;
            } else {
              currentThrottle = 5;
            }
          }

          const currentSign = Math.sign(currentEnginePower);
          const targetSign = Math.sign(currentThrottle);

          if (currentSign !== targetSign && currentEnginePower !== 0) {
            if (currentEnginePower > 0) {
              currentEnginePower = Math.max(
                0,
                currentEnginePower - ENGINE_POWER_RATE * dt,
              );
            } else {
              currentEnginePower = Math.min(
                0,
                currentEnginePower + ENGINE_POWER_RATE * dt,
              );
            }
            if (Math.abs(currentEnginePower) <= 0.1) {
              currentEnginePower = 0;
            }
          } else {
            const targetEnginePower = currentThrottle * 20;
            if (currentEnginePower < targetEnginePower) {
              currentEnginePower = Math.min(
                targetEnginePower,
                currentEnginePower + ENGINE_POWER_RATE * dt,
              );
            } else if (currentEnginePower > targetEnginePower) {
              currentEnginePower = Math.max(
                targetEnginePower,
                currentEnginePower - ENGINE_POWER_RATE * dt,
              );
            }
          }

          if (currentThrottle !== 0 && currentEnginePower !== 0) {
            const coalRateKgPerMin =
              Math.abs(currentEnginePower) * COAL_CONSUMPTION_RATE;
            const coalRateKgPerSec = coalRateKgPerMin / 60;
            const coalUsed = coalRateKgPerSec * dt;
            if (currentCoalReserve >= coalUsed) {
              currentCoalReserve -= coalUsed;
              coalBurned += coalUsed;
            } else {
              currentThrottle = 0;
              currentEnginePower = 0;
            }
          }

          const currentThrust = currentEnginePower / 100;
          let targetSpeed = currentThrust * MAX_SPEED;

          if (Math.abs(currentSpeed - targetSpeed) > 0.01) {
            let acceleration = ACCELERATION_FORWARD;
            if (Math.abs(currentEnginePower) < 0.1) {
              acceleration = DECELERATION_COAST;
            } else if (
              (currentEnginePower < 0 && currentSpeed > 0) ||
              (currentEnginePower > 0 && currentSpeed < 0)
            ) {
              acceleration = ACCELERATION_REVERSE;
            }

            if (currentSpeed < targetSpeed) {
              currentSpeed = Math.min(
                targetSpeed,
                currentSpeed + acceleration * dt,
              );
            } else {
              currentSpeed = Math.max(
                targetSpeed,
                currentSpeed - acceleration * dt,
              );
            }
          } else {
            currentSpeed = targetSpeed;
          }

          if (
            Math.abs(currentEnginePower) < 0.1 &&
            Math.abs(currentSpeed) > 0.1
          ) {
            const drag = DECELERATION_COAST * dt;
            if (currentSpeed > 0) {
              currentSpeed = Math.max(0, currentSpeed - drag);
            } else {
              currentSpeed = Math.min(0, currentSpeed + drag);
            }
          }

          if (Math.abs(currentSpeed) > 0.1) {
            const turnRate =
              MIN_TURN_RATE +
              (Math.abs(currentSpeed) / MAX_SPEED) *
                (MAX_TURN_RATE - MIN_TURN_RATE);
            const targetAngularVelocity = airshipData.rudder * turnRate;
            const angularAccel = 0.5;
            if (currentAngularVel < targetAngularVelocity) {
              currentAngularVel = Math.min(
                targetAngularVelocity,
                currentAngularVel + angularAccel * dt,
              );
            } else if (currentAngularVel > targetAngularVelocity) {
              currentAngularVel = Math.max(
                targetAngularVelocity,
                currentAngularVel - angularAccel * dt,
              );
            }
            currentHeading += currentAngularVel * dt;
            currentHeading = ((currentHeading % 360) + 360) % 360;
          } else {
            currentAngularVel *= 0.95;
            if (Math.abs(currentAngularVel) < 0.01) currentAngularVel = 0;
          }

          if (Math.abs(currentSpeed) > 0.1) {
            const distanceKm = (Math.abs(currentSpeed) * dt) / 3600;
            const distanceMeters = distanceKm * 1000;
            airshipData.totalDistanceMeters += distanceMeters;

            const headingRad = (currentHeading * Math.PI) / 180;
            const dx =
              distanceMeters * Math.sin(headingRad) * Math.sign(currentSpeed);
            const dy =
              distanceMeters * Math.cos(headingRad) * Math.sign(currentSpeed);
            const earthRadius = 6378137;
            currentLat += (dy / earthRadius) * (180 / Math.PI);
            currentLng +=
              ((dx / earthRadius) * (180 / Math.PI)) /
              Math.cos((currentLat * Math.PI) / 180);
          }
        }

        airshipData.lat = currentLat;
        airshipData.lng = currentLng;
        airshipData.heading = currentHeading;
        airshipData.speed = currentSpeed;
        airshipData.angularVelocity = currentAngularVel;
        airshipData.propRotationAngle = currentPropAngle;
        airshipData.totalCoalBurned += coalBurned;
        airshipData.coalReserve = currentCoalReserve;
        airshipData.enginePower = currentEnginePower;
        airshipData.virtualElapsedSeconds += secondsToSkip;
        airshipData.lastUpdate = Date.now();

        if (airshipData.coalReserve <= 0) {
          airshipData.throttle = 0;
          airshipData.enginePower = 0;
        }
      }

      function loadCoal() {
        const add = parseFloat(prompt("–°–∫–æ–ª—å–∫–æ –∫–≥ —É–≥–ª—è –∑–∞–≥—Ä—É–∑–∏—Ç—å?", "100"));
        if (!isNaN(add) && add > 0) {
          airshipData.coalReserve += add;
          updateStats();
          localStorage.setItem("airshipState", JSON.stringify(airshipData));
        }
      }

      let gameStarted = false;
      let awaitingSpawn = false;
      let awaitingTarget = false;

      function spawnAirship(lat, lng) {
        if (gameStarted || !lat || !lng) return;
        gameStarted = true;
        awaitingSpawn = false;

        if (airshipMarker) map.removeLayer(airshipMarker);
        airshipMarker = L.marker([lat, lng], {
          icon: L.divIcon({ className: "" }),
        }).addTo(map);
        Object.assign(airshipData, {
          lat,
          lng,
          heading: 0,
          speed: 0,
          throttle: 0,
          rudder: 0,
          angularVelocity: 0,
          lastUpdate: Date.now(),
          propRotationAngle: 0,
          flagEnabled: false,
          followEnabled: false,
          autopilotEnabled: false,
          fastBrakeEnabled: false,
          startTime: Date.now(),
          totalDistanceMeters: 0,
          coalReserve: 5000,
          totalCoalBurned: 0,
          hasTarget: false,
          targetLat: null,
          targetLng: null,
          virtualElapsedSeconds: 0,
          virtualStartTime: Date.now(),
          enginePower: 0,
          engineReversing: false,
        });

        document.getElementById("controls").style.display = "flex";
        document.getElementById("toggleControlsBtn").style.display = "block";
        document.getElementById("stats").style.display = "block";
        document.getElementById("autopilotToggle").disabled = true;

        updateDisplays();
        updateAirshipIcon();
        updateFlag();
        updateStats();
        startAutoSave();
      }

      let autoSaveInterval = null;
      function startAutoSave() {
        if (autoSaveInterval) clearInterval(autoSaveInterval);
        autoSaveInterval = setInterval(() => {
          if (airshipMarker) {
            localStorage.setItem("airshipState", JSON.stringify(airshipData));
          }
        }, 10000);
      }

      function loadFromUrl() {
        try {
          const urlParams = new URLSearchParams(window.location.search);

          const lat = parseFloat(urlParams.get("lat"));
          const lng = parseFloat(urlParams.get("lng"));
          if (
            isNaN(lat) ||
            isNaN(lng) ||
            Math.abs(lat) > 90 ||
            Math.abs(lng) > 180
          ) {
            return false;
          }

          airshipData.lat = lat;
          airshipData.lng = lng;

          const safeFloat = (key, def) => {
            const val = parseFloat(urlParams.get(key));
            return isNaN(val) ? def : val;
          };
          const safeInt = (key, def) => {
            const val = parseInt(urlParams.get(key), 10);
            return isNaN(val) ? def : val;
          };
          const safeBool = (key) => urlParams.get(key) === "1";

          airshipData.heading = safeFloat("hdg", 0);
          airshipData.speed = safeFloat("spd", 0);
          airshipData.throttle = safeInt("thr", 0);
          airshipData.rudder = safeFloat("rud", 0);
          airshipData.enginePower = safeFloat("eng", 0);
          airshipData.coalReserve = safeFloat("crl", 5000);
          airshipData.totalCoalBurned = safeFloat("cbn", 0);
          airshipData.hasTarget = safeBool("tgt");

          if (airshipData.hasTarget) {
            const tlt = safeFloat("tlt", NaN);
            const tlg = safeFloat("tlg", NaN);
            if (
              isNaN(tlt) ||
              isNaN(tlg) ||
              Math.abs(tlt) > 90 ||
              Math.abs(tlg) > 180
            ) {
              airshipData.hasTarget = false;
            } else {
              airshipData.targetLat = tlt;
              airshipData.targetLng = tlg;
            }
          }

          airshipData.autopilotEnabled = safeBool("apl");
          airshipData.fastBrakeEnabled = safeBool("fbr");

          const vst = safeInt("vst", 0);
          airshipData.virtualStartTime = vst > 0 ? vst * 1000 : Date.now();
          airshipData.virtualElapsedSeconds = safeFloat("vel", 0);
          airshipData.lastUpdate = Date.now();

          if (airshipMarker) map.removeLayer(airshipMarker);
          airshipMarker = L.marker([lat, lng], {
            icon: L.divIcon({ className: "" }),
          }).addTo(map);

          if (airshipData.hasTarget) {
            setTarget(airshipData.targetLat, airshipData.targetLng);
          }

          updateAirshipIcon();
          updateDisplays();
          updateStats();
          startAutoSave();

          document.getElementById("controls").style.display = "flex";
          document.getElementById("toggleControlsBtn").style.display = "block";
          document.getElementById("stats").style.display = "block";

          gameStarted = true;
          awaitingSpawn = false;
          document.getElementById("start-menu").style.display = "none";
          return true;
        } catch (e) {
          console.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑ URL:", e);
          return false;
        }
      }

      function loadSavedState() {
        try {
          const saved = localStorage.getItem("airshipState");
          const btnContinue = document.getElementById("btn-continue");
          if (saved) {
            const parsed = JSON.parse(saved);
            if (
              typeof parsed.lat === "number" &&
              typeof parsed.lng === "number"
            ) {
              btnContinue.disabled = false;
              btnContinue.onclick = () => {
                try {
                  document.getElementById("start-menu").style.display = "none";
                  spawnAirship(parsed.lat, parsed.lng);
                  Object.assign(airshipData, parsed);
                  gameStarted = true;
                  awaitingSpawn = false;

                  document.getElementById("controls").style.display = "flex";
                  document.getElementById("toggleControlsBtn").style.display =
                    "block";
                  document.getElementById("stats").style.display = "block";

                  updateDisplays();
                  updateAirshipIcon();
                  if (airshipData.flagEnabled) {
                    document.getElementById("flagToggle").checked = true;
                    updateFlag();
                  }
                  if (airshipData.followEnabled) {
                    document.getElementById("followToggle").checked = true;
                  }
                  if (airshipData.hasTarget) {
                    setTarget(airshipData.targetLat, airshipData.targetLng);
                  }
                  focusOnAirship(12);
                  startAutoSave();
                } catch (e) {
                  console.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑ localStorage:", e);
                  alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ.");
                }
              };
              return;
            }
          }
        } catch (e) {
          console.warn("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:", e);
        }
        document.getElementById("btn-continue").disabled = true;
      }

      const timeWarpSlider = document.getElementById("timeWarpSlider");
      const timeWarpValue = document.getElementById("timeWarpValue");
      timeWarpSlider.addEventListener("input", () => {
        const index = parseInt(timeWarpSlider.value);
        timeWarpFactor = timeSteps[index];
        updateDisplays();
      });

      let zoomDebounceTimer = null;

      zoomScaleSlider.addEventListener("input", () => {
        // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä
        if (zoomDebounceTimer) {
          clearTimeout(zoomDebounceTimer);
        }

        // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        currentZoomScaleIndex = parseInt(zoomScaleSlider.value);

        // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
        updateDisplays();

        // –û—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É –º–∞—Å—à—Ç–∞–±–∞ –Ω–∞ 500 –º—Å
        zoomDebounceTimer = setTimeout(() => {
          const zoomLevel = ZOOM_SCALE_LEVELS[currentZoomScaleIndex];
          map.setZoom(zoomLevel);
          zoomDebounceTimer = null;
        }, 100);
      });

      document.getElementById("pauseBtn").addEventListener("click", () => {
        isPaused = !isPaused;
        updateDisplays();
        startAutoSave();
      });

      const rudderSlider = document.getElementById("rudderSlider");
      const throttleSlider = document.getElementById("throttleSlider");
      const rudderValue = document.getElementById("rudderValue");
      const throttleValue = document.getElementById("throttleValue");

      rudderSlider.addEventListener("input", () => {
        airshipData.autopilotEnabled = false;
        document.getElementById("autopilotToggle").checked = false;
        const sliderVal = parseInt(rudderSlider.value);
        airshipData.rudder = sliderVal * 0.1;
        rudderValue.textContent = airshipData.rudder.toFixed(1) + "¬∞";
      });

      throttleSlider.addEventListener("input", () => {
        airshipData.autopilotEnabled = false;
        document.getElementById("autopilotToggle").checked = false;
        airshipData.throttle = parseInt(throttleSlider.value);
        throttleValue.textContent =
          throttleLabels[airshipData.throttle] || "STOP";
      });

      document
        .getElementById("fastBrakeToggle")
        .addEventListener("change", function () {
          airshipData.fastBrakeEnabled = this.checked;
          if (airshipData.fastBrakeEnabled && airshipData.speed <= 5) {
            this.checked = false;
            airshipData.fastBrakeEnabled = false;
          }
        });

      document
        .getElementById("flagToggle")
        .addEventListener("change", function () {
          airshipData.flagEnabled = this.checked;
          updateFlag();
        });

      document
        .getElementById("followToggle")
        .addEventListener("change", function () {
          airshipData.followEnabled = this.checked;
        });

      document
        .getElementById("autopilotToggle")
        .addEventListener("change", function () {
          airshipData.autopilotEnabled = this.checked;
          if (airshipData.autopilotEnabled && !airshipData.hasTarget) {
            this.checked = false;
            airshipData.autopilotEnabled = false;
            alert("–°–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ü–µ–ª—å!");
          }
        });

      document.getElementById("syncTimeBtn").addEventListener("click", () => {
        if (!airshipData.virtualStartTime) return;

        const realElapsedMs = Date.now() - airshipData.virtualStartTime;
        const virtualElapsedMs = airshipData.virtualElapsedSeconds * 1000;
        const diffMs = realElapsedMs - virtualElapsedMs;

        if (Math.abs(diffMs) > 1000) {
          const diffSec = Math.abs(diffMs) / 1000;
          skipSimulationTime(diffSec);
          alert(
            `–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ü—Ä–æ–ø—É—â–µ–Ω–æ ${Math.round(diffSec)} —Å–µ–∫.`,
          );
        } else {
          alert("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.");
        }
      });

      document.getElementById("focusBtn").addEventListener("click", () => {
        focusOnAirship(12);
      });

      document.getElementById("targetBtn").addEventListener("click", () => {
        if (airshipData.hasTarget) {
          removeTarget();
        } else {
          awaitingTarget = true;
          alert("–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ, —á—Ç–æ–±—ã —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ—á–∫—É –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è.");
        }
      });

      document.getElementById("coalBtn").addEventListener("click", loadCoal);

      document.getElementById("newGameBtn").addEventListener("click", () => {
        if (confirm("–í—ã —É–≤–µ—Ä–µ–Ω—ã? –¢–µ–∫—É—â–∏–π –ø–æ–ª—ë—Ç –±—É–¥–µ—Ç —Å–±—Ä–æ—à–µ–Ω.")) {
          window.history.replaceState(null, "", window.location.pathname);
          location.reload();
        }
      });

      document
        .getElementById("toggleControlsBtn")
        .addEventListener("click", () => {
          const controls = document.getElementById("controls");
          const btn = document.getElementById("toggleControlsBtn");
          if (controls.style.display === "none") {
            controls.style.display = "flex";
            btn.textContent = "^";
          } else {
            controls.style.display = "none";
            btn.textContent = "‚åÑ";
          }
        });

      function simulateStep() {
        if (!airshipMarker || isPaused) return;

        const now = Date.now();
        const dtReal = (now - airshipData.lastUpdate) / 1000;
        const dtSimulated = dtReal * timeWarpFactor;
        airshipData.virtualElapsedSeconds += dtSimulated;
        airshipData.lastUpdate = now;

        if (airshipData.fastBrakeEnabled && airshipData.speed > 5) {
          airshipData.throttle = -5;
        } else if (airshipData.speed <= 5 && airshipData.fastBrakeEnabled) {
          airshipData.fastBrakeEnabled = false;
          document.getElementById("fastBrakeToggle").checked = false;
          airshipData.throttle = 0;
        }

        if (airshipData.autopilotEnabled) {
          runAutopilot();
        }

        const currentSign = Math.sign(airshipData.enginePower);
        const targetSign = Math.sign(airshipData.throttle);

        if (currentSign !== targetSign && airshipData.enginePower !== 0) {
          if (airshipData.enginePower > 0) {
            airshipData.enginePower = Math.max(
              0,
              airshipData.enginePower - ENGINE_POWER_RATE * dtSimulated,
            );
          } else {
            airshipData.enginePower = Math.min(
              0,
              airshipData.enginePower + ENGINE_POWER_RATE * dtSimulated,
            );
          }
          if (Math.abs(airshipData.enginePower) <= 0.1) {
            airshipData.enginePower = 0;
          }
        } else {
          const targetEnginePower = airshipData.throttle * 20;
          if (airshipData.enginePower < targetEnginePower) {
            airshipData.enginePower = Math.min(
              targetEnginePower,
              airshipData.enginePower + ENGINE_POWER_RATE * dtSimulated,
            );
          } else if (airshipData.enginePower > targetEnginePower) {
            airshipData.enginePower = Math.max(
              targetEnginePower,
              airshipData.enginePower - ENGINE_POWER_RATE * dtSimulated,
            );
          }
        }

        let coalUsed = 0;
        if (
          airshipData.throttle !== 0 &&
          airshipData.enginePower !== 0 &&
          airshipData.coalReserve > 0
        ) {
          const coalRateKgPerMin =
            Math.abs(airshipData.enginePower) * COAL_CONSUMPTION_RATE;
          const coalRateKgPerSec = coalRateKgPerMin / 60;
          coalUsed = coalRateKgPerSec * dtSimulated;
          if (airshipData.coalReserve >= coalUsed) {
            airshipData.coalReserve -= coalUsed;
            airshipData.totalCoalBurned += coalUsed;
          } else {
            airshipData.coalReserve = 0;
            airshipData.throttle = 0;
            airshipData.enginePower = 0;
          }
        }

        const rpm = calculatePropellerRPM();
        if (rpm !== 0) {
          const rotationPerSecond = (Math.abs(rpm) * 360) / 60;
          airshipData.propRotationAngle +=
            rotationPerSecond * dtSimulated * Math.sign(rpm);
          airshipData.propRotationAngle %= 360;
        }

        const currentThrust = airshipData.enginePower / 100;
        let targetSpeed = currentThrust * MAX_SPEED;

        if (Math.abs(airshipData.speed - targetSpeed) > 0.01) {
          let acceleration = ACCELERATION_FORWARD;
          if (Math.abs(airshipData.enginePower) < 0.1) {
            acceleration = DECELERATION_COAST;
          } else if (
            (airshipData.enginePower < 0 && airshipData.speed > 0) ||
            (airshipData.enginePower > 0 && airshipData.speed < 0)
          ) {
            acceleration = ACCELERATION_REVERSE;
          }

          if (airshipData.speed < targetSpeed) {
            airshipData.speed = Math.min(
              targetSpeed,
              airshipData.speed + acceleration * dtSimulated,
            );
          } else {
            airshipData.speed = Math.max(
              targetSpeed,
              airshipData.speed - acceleration * dtSimulated,
            );
          }
        } else {
          airshipData.speed = targetSpeed;
        }

        if (
          Math.abs(airshipData.enginePower) < 0.1 &&
          Math.abs(airshipData.speed) > 0.1
        ) {
          const drag = DECELERATION_COAST * dtSimulated;
          if (airshipData.speed > 0) {
            airshipData.speed = Math.max(0, airshipData.speed - drag);
          } else {
            airshipData.speed = Math.min(0, airshipData.speed + drag);
          }
        }

        if (Math.abs(airshipData.speed) > 0.1) {
          const turnRate =
            MIN_TURN_RATE +
            (Math.abs(airshipData.speed) / MAX_SPEED) *
              (MAX_TURN_RATE - MIN_TURN_RATE);
          const targetAngularVelocity = airshipData.rudder * turnRate;
          const angularAccel = 0.5;
          if (airshipData.angularVelocity < targetAngularVelocity) {
            airshipData.angularVelocity = Math.min(
              targetAngularVelocity,
              airshipData.angularVelocity + angularAccel * dtSimulated,
            );
          } else if (airshipData.angularVelocity > targetAngularVelocity) {
            airshipData.angularVelocity = Math.max(
              targetAngularVelocity,
              airshipData.angularVelocity - angularAccel * dtSimulated,
            );
          }
          airshipData.heading += airshipData.angularVelocity * dtSimulated;
          airshipData.heading = ((airshipData.heading % 360) + 360) % 360;
        } else {
          airshipData.angularVelocity *= 0.95;
          if (Math.abs(airshipData.angularVelocity) < 0.01)
            airshipData.angularVelocity = 0;
        }

        if (Math.abs(airshipData.speed) > 0.1) {
          const distanceKm = (Math.abs(airshipData.speed) * dtSimulated) / 3600;
          const distanceMeters = distanceKm * 1000;
          airshipData.totalDistanceMeters += distanceMeters;

          const headingRad = (airshipData.heading * Math.PI) / 180;
          const dx =
            distanceMeters *
            Math.sin(headingRad) *
            Math.sign(airshipData.speed);
          const dy =
            distanceMeters *
            Math.cos(headingRad) *
            Math.sign(airshipData.speed);
          const earthRadius = 6378137;
          const newLat = airshipData.lat + (dy / earthRadius) * (180 / Math.PI);
          const newLng =
            airshipData.lng +
            ((dx / earthRadius) * (180 / Math.PI)) /
              Math.cos((airshipData.lat * Math.PI) / 180);
          airshipData.lat = newLat;
          airshipData.lng = newLng;
          airshipMarker.setLatLng([newLat, newLng]);
          if (flagMarker) flagMarker.setLatLng([newLat, newLng]);

          if (airshipData.followEnabled) {
            map.panTo([newLat, newLng], { animate: false });
          }

          if (airshipData.hasTarget) {
            updateDirectionArrow();
          }
        }

        updateDisplays();
        updateAirshipIcon();
        updateStats();
        updateUrl();
      }

      map.on("click", (e) => {
        if (awaitingSpawn) {
          spawnAirship(e.latlng.lat, e.latlng.lng);
        } else if (awaitingTarget) {
          awaitingTarget = false;
          setTarget(e.latlng.lat, e.latlng.lng);
        }
      });

      map.on("zoomend", () => {
        if (airshipMarker) updateAirshipIcon();
      });

      document.getElementById("btn-new").onclick = () => {
        document.getElementById("start-menu").style.display = "none";
        awaitingSpawn = true;
      };

      if (!loadFromUrl()) {
        loadSavedState();
      }

      setInterval(simulateStep, 50);
    </script>
  </body>
</html>
